// Copyright (C) 2007 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview the Caja runtime library.
 * It is written in Javascript, not Caja, and would be rejected by the Caja
 * translator. This module exports two globals:<ol>
 * <li>"___" for use by the output of the Caja translator and by some
 *     other untranslated Javascript code.
 * <li>"caja" providing some common services to the Caja programmer.
 * </ol>
 * @author erights@gmail.com
 */

// TODO(erights): All code text in comments should be enclosed in
// {@code ...}.


////////////////////////////////////////////////////////////////////////
// Caja adds the following common Javascript extensions to ES3
// TODO(erights): Move such extensions to a separate extensions.js,
//                and change the conflict rule (for now) to fail on
//                detecting a conflict.
////////////////////////////////////////////////////////////////////////

// Add a tag to whitelisted builtin constructors so we can check the class
// cross-frame. Note that Function is not on the list.

Array.typeTag___ = 'Array';
Object.typeTag___ = 'Object';
String.typeTag___ = 'String';
Boolean.typeTag___ = 'Boolean';
Number.typeTag___ = 'Number';
Date.typeTag___ = 'Date';
RegExp.typeTag___ = 'RegExp';
Error.typeTag___ = 'Error';
EvalError.typeTag___ = 'EvalError';
RangeError.typeTag___ = 'RangeError';
ReferenceError.typeTag___ = 'ReferenceError';
SyntaxError.typeTag___ = 'SyntaxError';
TypeError.typeTag___ = 'TypeError';
URIError.typeTag___ = 'URIError';


if (Array.prototype.indexOf === (void 0)) {
  /**
   * Returns the first index at which the specimen is found (by
   * "===") or -1 if none.
   */
  Array.prototype.indexOf = function(specimen) {
    var len = this.length;
    for (var i = 0; i < len; i += 1) {
      if (this[i] === specimen) {
        return i;
      }
    }
    return -1;
  };
}

if (Array.prototype.lastIndexOf === (void 0)) {
  /**
   * Returns the last index at which the specimen is found (by
   * "===") or -1 if none.
   */
  Array.prototype.lastIndexOf = function(specimen) {
    for (var i = this.length; --i >= 0; ) {
      if (this[i] === specimen) {
        return i;
      }
    }
    return -1;
  };
}

if (Date.prototype.toISOString === (void 0)) {
  /** In anticipation of ES3.1 */
  Date.prototype.toISOString = function() {
    function f(n) {
      return n < 10 ? '0' + n : n;
    }
    return (this.getUTCFullYear()     + '-' +
            f(this.getUTCMonth() + 1) + '-' +
            f(this.getUTCDate())      + 'T' +
            f(this.getUTCHours())     + ':' +
            f(this.getUTCMinutes())   + ':' +
            f(this.getUTCSeconds())   + 'Z');
  };
}

if (Date.prototype.toJSON === (void 0)) {
  /** In anticipation of ES3.1 */
  Date.prototype.toJSON = Date.prototype.toISOString;
}

if (Array.slice === (void 0)) {
  /** In anticipation of ES4, and because it's useful. */
  Array.slice = function(self, start, end) {
    return Array.prototype.slice.call(self, start || 0, end || self.length);
  };
}

if (Function.prototype.bind === (void 0)) {
  /**
   * In anticipation of ES3.1.
   * <p>
   * Bind this function to <tt>self</tt>, which will serve
   * as the value of <tt>this</tt> during invocation. Curry on a
   * partial set of arguments in <tt>var_args</tt>. Return the curried
   * result as a new function object.
   * <p>
   * Note: Like the built-in Function.prototype.call and
   * Function.prototype.apply, this one is not whitelisted. Instead,
   * it is provided as it would be in future JavaScripts without
   * special knowledge of Caja. This allows Caja code using bind() to
   * work today uncajoled as well. It also suppresses the overriding
   * of 'bind' by the 'in' test in setStatic().
   * <p>
   * Note that this is distinct from the tamed form of bind() made
   * available to Caja code.
   */
  Function.prototype.bind = function(self, var_args) {
    var thisFunc = this;
    var leftArgs = Array.slice(arguments, 1);
    return function(var_args) {
      var args = leftArgs.concat(Array.slice(arguments, 0));
      return thisFunc.apply(self, args);
    };
  };
}

Function.prototype['super'] = function() {
  caja.fail('"super" may only be called ',
            'at the beginning of a Caja constructor.');
};

// caja.js exports the following names to the Javascript global
// namespace. Caja code can only use the "caja" object. The "___"
// object is for use by code generated by the Caja translator, and by
// Javascript code (such as a powerbox) in the embedding application.

var caja;
var ___;

// Explicitly passing in the actual global object to avoid
// ReferenceErrors when referring to potentially nonexistent objects
// like HTMLDivElement.

(function(global) {

  ////////////////////////////////////////////////////////////////////////
  // Some regular expressions checking for specific suffixes.
  ////////////////////////////////////////////////////////////////////////

  var endsWith_canDelete___ = /_canDelete___$/;
  var endsWith_canRead___ = /_canRead___$/;
  var endsWith_canSet___ = /_canSet___$/;
  var endsWith___ = /___$/;
  var endsWith__ = /__$/;
  var endsWith_ = /_$/;
  
  ////////////////////////////////////////////////////////////////////////
  // Some very basic primordial methods
  ////////////////////////////////////////////////////////////////////////

  var myOriginalHOP = Object.prototype.hasOwnProperty;

  /**
   * <tt>hasOwnProp(obj, name)</tt> means what
   * <tt>obj.hasOwnProperty(name)</tt> would normally mean in an
   * unmodified Javascript system.
   */
  function hasOwnProp(obj, name) { 
    var t = typeof obj;
    if (t !== 'object' && t !== 'function') {
      // If obj is a primitive, Object(obj) still has no own properties.
      return false; 
    }
    return myOriginalHOP.call(obj, name);
  }
  
  // Returns identity for a decent === check.
  Object.prototype.getIdent___ = function() { return this; };
  String.prototype.getIdent___ = String.prototype.valueOf;
  Boolean.prototype.getIdent___ = Boolean.prototype.valueOf;
  var NaNIdent = {};
  var MinusZeroIdent = {};
  Number.prototype.getIdent___ = function() {
    var result = this.valueOf();
    if (isNaN(result)) { return NaNIdent; }
    if (result === 0 && 1/result === -Infinity) { return MinusZeroIdent; }
    return result;
  };

  /**
   * Turns wrappers of primitives into the primitives themselves, and
   * then compares if they are otherwise computationally identical.
   */
  function same(x, y) {
    if (x === null || x === (void 0) || y === null || y === (void 0)) {
      return x === y;
    }
    return x.getIdent___() === y.getIdent___();
  }


  ////////////////////////////////////////////////////////////////////////
  // Diagnostics and condition enforcement
  ////////////////////////////////////////////////////////////////////////

  /**
   * The initial default logging function does nothing.
   * <p>
   * Note: JavaScript has no macros, so even in the "does nothing"
   * case, remember that the arguments are still evaluated.
   */
  var myLogFunc = simpleFrozenFunc(function(str, opt_stop) {});

  /**
   * Gets the currently registered logging function.
   */
  function getLogFunc() { return myLogFunc; }

  /**
   * Register newLogFunc as the current logging function, to be called
   * by <tt>___.log(str)</tt> and <tt>___.fail(...)</tt>.
   * <p>
   * A logging function is assumed to have the signature
   * <tt>(str, opt_stop)</tt>, where<ul>
   * <li><tt>str</tt> is the diagnostic string to be logged, and
   * <li><tt>opt_stop</tt>, if present and <tt>true</tt>, indicates
   *     that normal flow control is about to be terminated by a
   *     throw. This provides the logging function the opportunity to
   *     terminate normal control flow in its own way, such as by
   *     invoking an undefined method, in order to trigger a Firebug
   *     stacktrace.
   * </ul>
   */
  function setLogFunc(newLogFunc) { myLogFunc = newLogFunc; }

  /**
   * Calls the currently registered logging function.
   */
  function log(str) { myLogFunc(String(str)); }


  /**
   * Throw, and optionally log, an error whose message is the
   * concatenation of the arguments.
   * <p>
   * The arguments are converted to strings (presumably by an
   * implicit call to ".toString()") and appended together to make
   * the message of the Error that's thrown.
   */
  function fail(var_args) {
    // TODO(metaweta): Ask mike samuel about this vs. log-to-console.js
    if ((typeof console !== 'undefined') && 
        (typeof console.trace === 'function')) {
      console.trace();
    }
    var message = Array.slice(arguments, 0).join('');
    myLogFunc(message, true);
    throw new Error(message);
  }

  /**
   * Like an assert that can't be turned off.
   * <p>
   * Either returns true (on success) or throws (on failure). The
   * arguments starting with <tt>var_args</tt> are converted to
   * strings and appended together to make the message of the Error
   * that's thrown.
   * <p>
   * TODO(erights) We may deprecate this in favor of <pre>
   *     test || fail(var_args...)
   * </pre> or <pre>
   *     if (!test) { fail(var_args...); }
   * </pre>
   */
  function enforce(test, var_args) {
    return test || fail.apply({}, Array.slice(arguments, 1));
  }

  /**
   * Enforces <tt>typeof specimen === typename</tt>, in which case
   * specimen is returned.
   * <p>
   * If not, throws an informative TypeError
   * <p>
   * opt_name, if provided, should be a name or description of the
   * specimen used only to generate friendlier error messages.
   */
  function enforceType(specimen, typename, opt_name) {
    if (typeof specimen !== typename) {
      fail('expected ', typename, ' instead of ', typeof specimen,
           ': ', (opt_name || specimen));
    }
    return specimen;
  }

  /**
   * Enforces that specimen is a non-negative integer within the range
   * of exactly representable consecutive integers, in which case
   * specimen is returned.
   * <p>
   * "Nat" is short for "Natural number".
   */
  function enforceNat(specimen) {
    enforceType(specimen, 'number');
    if (Math.floor(specimen) !== specimen) {
      fail('Must be integral: ', specimen);
    }
    if (specimen < 0) {
      fail('Must not be negative: ', specimen);
    }
    // Could pre-compute precision limit, but probably not faster
    // enough to be worth it.
    if (Math.floor(specimen-1) !== specimen-1) {
      fail('Beyond precision limit: ', specimen);
    }
    if (Math.floor(specimen-1) >= specimen) {
      fail('Must not be infinite: ', specimen);
    }
    return specimen;
  }

  ////////////////////////////////////////////////////////////////////////
  // Privileged fault handlers
  ////////////////////////////////////////////////////////////////////////

  function debugReference(obj) {
    switch (typeof obj) {
      case 'object': {
        if (obj === null) { return '<null>'; }
        return '[' + (directConstructor(obj).name || 'Object') + ']';
      }
      default: { 
        return '(' + obj + ':' + (typeof obj) + ')'; 
      }
    }
  }

  /**
   *
   */
  var myKeeper = {

    /**
     *
     */
    toString: function() { return '<Logging Keeper>'; },

    /**
     *
     */
    handleRead: function(obj, name) {
      log('Not readable: (' + debugReference(obj) + ').' + name);
      return (void 0);
    },

    /**
     *
     */
    handleCall: function(obj, name, args) {
      fail('Not callable: (', debugReference(obj), ').', name);
    },

    /**
     *
     */
    handleSet: function(obj, name, val) {
      fail('Not settable: (', debugReference(obj), ').', name);
    },

    /**
     *
     */
    handleDelete: function(obj, name) {
      fail('Not deletable: (', debugReference(obj), ').', name);
    }
  };

  /**
   *
   */
  Object.prototype.handleRead___ = function(name) {
    var handlerName = name + '_getter___';
    if (this[handlerName]) {
      return this[handlerName]();
    }
    return myKeeper.handleRead(this, name);
  };

  /**
   *
   */
  Object.prototype.handleCall___ = function(name, args) {
    var handlerName = name + '_handler___';
    if (this[handlerName]) {
      return this[handlerName].call(this, args);
    }
    return myKeeper.handleCall(this, name, args);
  };

  /**
   *
   */
  Object.prototype.handleSet___ = function(name, val) {
    var handlerName = name + '_setter___';
    if (this[handlerName]) {
      return this[handlerName](val);
    }
    return myKeeper.handleSet(this, name, val);
  };

  /**
   *
   */
  Object.prototype.handleDelete___ = function(name) {
    var handlerName = name + '_deleter___';
    if (this[handlerName]) {
      return this[handlerName]();
    }
    return myKeeper.handleDelete(this, name);
  };

  ////////////////////////////////////////////////////////////////////////
  // walking prototype chain, checking JSON containers
  ////////////////////////////////////////////////////////////////////////

  /**
   * Does str end with suffix?
   */
  function endsWith(str, suffix) {
    enforceType(str, 'string');
    enforceType(suffix, 'string');
    var d = str.length - suffix.length;
    return d >= 0 && str.lastIndexOf(suffix) === d;
  }

  /**
   * Returns the 'constructor' property of obj's prototype.
   * <p>
   * SECURITY TODO(erights): Analyze the security implications
   * of exposing this as a property of the caja object.
   * <p>
   * By "obj's prototype", we mean the prototypical object that obj
   * most directly inherits from, not the value of its 'prototype'
   * property. We memoize the apparent prototype into 'proto___' to
   * speed up future queries. 
   * <p>
   * If obj is a function or not an object, return undefined.
   */
  function directConstructor(obj) {
    if (obj === null) { return (void 0); }
    if (obj === void 0) { return (void 0); }
    // TODO(erights): This won't work for a cross-frame RegExp,
    // but we can't use isInstanceOf(), because it depends on 
    // directConstructor().
    if (typeof obj === 'function' && !(obj instanceof RegExp)) {
      // Since functions return undefined,
      // directConstructor() doesn't provide access to the
      // forbidden Function constructor.
      return (void 0);
    }
    obj = Object(obj);
    var result;
    if (hasOwnProp(obj, 'proto___')) {
      var proto = obj.proto___;
      if (proto === null) { return (void 0); }
      if (isPrototypical(proto)) {
        result = proto.constructor;
      } else {
        result = directConstructor(proto);
      }
    } else {
      if (!hasOwnProp(obj, 'constructor')) {
        // TODO(erights): Detect whether this is a valid constructor
        // property in the sense that result is a proper answer. If
        // not, at least give a sensible error, which will be hard to
        // phrase. 
        result = obj.constructor;
      } else {
        var oldConstr = obj.constructor;
        if (delete obj.constructor) { 
          result = obj.constructor;
          obj.constructor = oldConstr;
        } else if (isPrototypical(obj)) {
          // A difficult case. In Safari, and perhaps according to
          // ES3, the prototypical object created for the default
          // value of a function's 'prototype' property has a
          // non-deletable 'constructor' property. If this is what we
          // have, then we assume it inherits directly from
          // Object.prototype, so the result should be Object.
          result = Object;
        } else {
          fail('Discovery of direct constructors unsupported when the ',
               'constructor property is not deletable: ',
               oldConstr); 
        }
      }
      if (typeof result !== 'function' || !(obj instanceof result)) {
        fail('Discovery of direct constructors for foreign begotten ',
             'objects not implemented on this platform.\n');
      }
      if (result.prototype.constructor === result) {
        // Memoize, so it'll be faster next time.
        obj.proto___ = result.prototype;
      }
    }
    return result;
  }

  /**
   * The function category of the whitelisted global constructors
   * defined in ES is the string name of the constructor, allowing
   * isInstanceOf() to work cross-frame. Otherwise, the function
   * category of a function is just the function itself.  
   */
  function getFuncCategory(fun) {
    enforceType(fun, 'function');
    if (fun.typeTag___) { 
      return fun.typeTag___; 
    } else {
      return fun;
    }
  }

  /**
   * Is <tt>obj</tt> a direct instance of a function whose category is
   * the same as the category of <tt>ctor</tt>? 
   */
  function isDirectInstanceOf(obj, ctor) {
    var constr = directConstructor(obj);
    if (constr === (void 0)) { return false; }
    return getFuncCategory(constr) === getFuncCategory(ctor);
  }

  /**
   */
  function isInstanceOf(obj, ctor) {
    if (obj instanceof ctor) { return true; }
    if (isDirectInstanceOf(obj, ctor)) { return true; }
    // BUG TODO(erights): walk prototype chain.
    // In the meantime, this will fail should it encounter a
    // cross-frame instance of a "subclass" of ctor.
    return false;
  }
  
  /**
   * A Record is an object whose direct constructor is Object.
   * <p>
   * These are the kinds of objects that can be expressed as 
   * an object literal ("<tt>{...}</tt>") in the JSON language.
   */
  function isRecord(obj) {
    return isDirectInstanceOf(obj, Object);
  }
  
  /**
   * An Array is an object whose direct constructor is Array.
   * <p>
   * These are the kinds of objects that can be expressed as 
   * an array literal ("<tt>[...]</tt>") in the JSON language.
   */
  function isArray(obj) {
    return isDirectInstanceOf(obj, Array);
  }

  /**
   * A JSON container is an object whose direct constructor is
   * Object or Array.
   * <p>
   * These are the kinds of non-primitive objects that can be
   * expressed in the JSON language.
   */
  function isJSONContainer(obj) {
    var constr = directConstructor(obj);
    if (constr === (void 0)) { return false; }
    var typeTag = constr.typeTag___;
    return typeTag === 'Object' || typeTag === 'Array';
  }

  /**
   * If obj is frozen, Caja code cannot directly assign to
   * properties of obj, nor directly add or delete properties to
   * obj.
   * <p>
   * The status of being frozen is not inherited. If A inherits from
   * B (i.e., if A's prototype is B), then (we hope) B must be
   * frozen regardless, but A may or may not be frozen.
   * <p>
   * If typeof <tt>obj</tt> is neither 'object' nor 'function', then
   * it's currently considered frozen.
   */
  function isFrozen(obj) {
    var t = typeof obj;
    if (t !== 'object' && t !== 'function') {
      return true;
    }
    if (obj === null) { return true; }
    // TODO(erights): Object(<primitive>) wrappers should also be
    // considered frozen.
    return hasOwnProp(obj, 'FROZEN___');
  }

  /**
   * Mark obj as frozen so that Caja code cannot directly assign to its
   * properties.
   * <p>
   * If obj is a function, also freeze obj.prototype.
   * <p>
   * This appears as <tt>___.primFreeze(obj)</tt> and is wrapped by
   * <tt>caja.freeze(obj)</tt>, which applies only to JSON containers.
   */
  function primFreeze(obj) {
    // Fail silently on undefined, since
    //   (function(){
    //     var f = Foo;
    //     if (true) { function Foo() {} }
    //   })();
    // gets translated to (roughly)
    //   (function(){
    //     var Foo;
    //     var f = ___.primFreeze(Foo);
    //     if (true) { Foo = function Foo() {}; }
    //   })();
    if (isFrozen(obj)) { return obj; }

    // badFlags are names of properties we need to turn off.
    // We accumulate these first, so that we're not in the midst of a
    // for/in loop on obj while we're deleting properties from obj.
    var badFlags = [];
    for (var k in obj) {
      if (endsWith_canSet___.test(k) || endsWith_canDelete___.test(k)) {
        if (obj[k]) {
          badFlags.push(k);
        }
      }
    }
    for (var i = 0; i < badFlags.length; i++) {
      var flag = badFlags[i];
      if (hasOwnProp(obj, flag)) {
        if (!(delete obj[flag])) {
          fail('internal: failed delete: ', debugReference(obj), '.', flag);
        }
      }
      if (obj[flag]) {
        // At the time of this writing, this case
        // should never be able to happen, since
        // prototypes are always frozen before use,
        // and frozen objects cannot have these flags
        // set on them. We code it this way to allow
        // for a future optimization, where the
        // prototype can record as canSet those
        // properties that appear in instances that
        // inherit from this prototype.
        obj[flag] = false;
      }
    }
    obj.FROZEN___ = true;
    if (typeof obj === 'function') {
      // Do last to avoid possible infinite recursion.
      if (obj.prototype) { primFreeze(obj.prototype); }
    }
    return obj;
  }

  /**
   * Like primFreeze(obj), but applicable only to JSON containers and
   * (pointlessly but harmlessly) to functions.
   */
  function freeze(obj) {
    if (!isJSONContainer(obj)) {
      if (typeof obj === 'function' && !isInstanceOf(obj, RegExp)) {
        enforce(isFrozen(obj), 'Internal: non-frozen function: ' + obj);
        return obj;
      }
      fail('caja.freeze(obj) applies only to JSON Containers: ',
           debugReference(obj));
    }
    return primFreeze(obj);
  }

  /**
   * Makes a mutable copy of a JSON container.
   * <p>
   * Even if the original is frozen, the copy will still be mutable.
   */
  function copy(obj) {
    if (!isJSONContainer(obj)) {
      fail('caja.copy(obj) applies only to JSON Containers: ',
           debugReference(obj));
    }
    var result = isArray(obj) ? [] : {};
    each(obj, simpleFrozenFunc(function(k, v) {
      result[k] = v;
    }));
    return result;
  }

  /**
   * A snapshot of a JSON container is a frozen copy of that
   * container.
   */
  function snapshot(obj) {
    return primFreeze(copy(obj));
  }


  ////////////////////////////////////////////////////////////////////////
  // Accessing property attributes
  ////////////////////////////////////////////////////////////////////////

  /** Tests whether the fast-path canRead flag is set. */
  function canRead(obj, name)   { return !!obj[name + '_canRead___']; }

  /** Tests whether the fast-path canEnum flag is set. */
  function canEnum(obj, name)   { return !!obj[name + '_canEnum___']; }
  /**
   * Tests whether the fast-path canCall flag is set, or grantCall() has been
   * called.
   */
  function canCall(obj, name)   {
    return !!(obj[name + '_canCall___'] || obj[name + '_grantCall___']);
  }
  /**
   * Tests whether the fast-path canSet flag is set, or grantSet() has been
   * called.
   */
  function canSet(obj, name) {
    return !!(obj[name + '_canSet___'] || obj[name + '_grantSet___']);
  }
  /** Tests whether the fast-path canDelete flag is set. */
  function canDelete(obj, name) { return !!obj[name + '_canDelete___']; }

  /**
   * Sets the fast-path canRead flag.
   * <p>
   * These are called internally to memoize decisions arrived at by
   * other means.
   */
  function fastpathRead(obj, name) {
    if (name === 'toString') { fail("internal: Can't fastpath .toString"); }
    obj[name + '_canRead___'] = true;
  }

  function fastpathEnumOnly(obj, name) {
    obj[name + '_canEnum___'] = true;
  }

  /**
   * Simple functions should callable and readable, but methods
   * should only be callable.
   */
  function fastpathCall(obj, name) {
    if (name === 'toString') { fail("internal: Can't fastpath .toString"); }
    obj[name + '_canCall___'] = true;
    if (obj[name + '_canSet___']) {
      obj[name + '_canSet___'] = false;
    }
    if (obj[name + '_grantSet___']) {
      obj[name + '_grantSet___'] = false;
    }
  }

  /**
   * fastpathSet implies fastpathEnumOnly and fastpathRead. It also
   * disables the ability to call.
   */
  function fastpathSet(obj, name) {
    if (name === 'toString') { fail("internal: Can't fastpath .toString"); }
    if (isFrozen(obj)) {
      fail("Can't set .", name, ' on frozen (', debugReference(obj), ')');
    }
    fastpathEnumOnly(obj, name);
    fastpathRead(obj, name);
    obj[name + '_canSet___'] = true;
    if (obj[name + '_canCall___']) {
      obj[name + '_canCall___'] = false;
    }
    if (obj[name + '_grantCall___']) {
      obj[name + '_grantCall___'] = false;
    }
  }

  /**
   * fastpathDelete allows delete of a member on a constructed object via
   * the private API.
   * <p>
   * TODO(erights): Having a fastpath flag for this probably doesn't
   * make sense.
   */
  function fastpathDelete(obj, name) {
    if (name === 'toString') { fail("internal: Can't fastpath .toString"); }
    if (isFrozen(obj)) {
      fail("Can't delete .", name, ' on frozen (', debugReference(obj), ')');
    }
    obj[name + '_canDelete___'] = true;
  }

  /**
   * The various <tt>grant*</tt> functions are called externally by
   * Javascript code to express whitelisting taming decisions.
   */
  function grantRead(obj, name) {
    fastpathRead(obj, name);
  }

  function grantEnumOnly(obj, name) {
    fastpathEnumOnly(obj, name);
  }

  function grantCall(obj, name) {
//    fastpathCall(obj, name);
    obj[name + '_grantCall___'] = true;
  }

  function grantSet(obj, name) {
//    fastpathSet(obj, name);
    obj[name + '_grantSet___'] = true;
  }

  function grantDelete(obj, name) {
    fastpathDelete(obj, name);
  }

  ////////////////////////////////////////////////////////////////////////
  // Classifying functions
  ////////////////////////////////////////////////////////////////////////

  function isCtor(constr)    {
    return (typeof(constr) === 'function') && !!constr.CONSTRUCTOR___;
  }
  function isMethod(meth)    {
    return (typeof meth === 'function') && !!meth.METHOD___;
  }
  function isSimpleFunc(fun) {
    return (typeof fun === 'function')  && !!fun.SIMPLEFUNC___;
  }
  function isXo4aFunc(func) {
    return (typeof func === 'function') && !!func.XO4A___;
  }

  /**
   * Mark <tt>constr</tt> as a constructor.
   * <p>
   * If <tt>opt_Sup</tt> is provided, set constr.super to a function which
   * calls the super constructor to do its part in initializing the object.
   * <p>
   * A function is tamed and classified by calling one of
   * <tt>ctor()</tt>, <tt>method()</tt>, or <tt>simpleFunc()</tt>. Each
   * of these checks that the function hasn't already been classified by
   * any of the others. A function which has not been so classified is an
   * <i>untamed function</i>.
   * <p>
   * <tt>opt_name</tt>, if provided, should be the name of the constructor
   * function. Currently, this is used only to generate friendlier
   * error messages.
   */
  function ctor(constr, opt_Sup, opt_name) {
    enforceType(constr, 'function', opt_name);
    if (isMethod(constr)) {
      fail("Methods can't be constructors: ", constr);
    }
    if (isSimpleFunc(constr)) {
      fail("Simple functions can't be constructors: ", constr);
    }
    if (isXo4aFunc(constr)) {
      fail("Exophoric functions can't be constructors: ", constr);
    }
    constr.CONSTRUCTOR___ = true;
    derive(constr, opt_Sup);
    if (opt_name) {
      constr.NAME___ = String(opt_name);
    }
    return constr;  // translator freezes constructor later
  }

  function derive(constr, opt_Sup) {
    if (opt_Sup) {
      opt_Sup = asCtor(opt_Sup);
      if (hasOwnProp(constr, 'super')) {
        fail("Can't inherit twice: ", constr, ',', opt_Sup);
      }
      if (isFrozen(constr)) {
        fail('Derived constructor already frozen: ', constr);
      }
      constr['super'] = function(thisObj, var_args) {
        return opt_Sup.apply(
            thisObj, Array.slice(arguments, 1));
      };
      if (!isFrozen(constr.prototype)) {
        // Some platforms, like Safari, actually conform to the part
        // of the ES3 spec which states that the constructor property
        // of implicitly created prototypical objects are not
        // deletable. But this prevents the inheritance-walking
        // algorithm (kludge) in directConstructor from working. Thus,
        // we set proto___ here so that directConstructor can skip
        // that impossible case.
        constr.prototype.proto___ = opt_Sup.prototype;
      }
    }
  }

  /**
   * Supports the split-translation for first-class constructors.
   * <p>
   * The split translation translates a constructor definition (which
   * must not appear as an expression) like<pre>
   *   function Point(x, y) {
   *     this.x_ = x;
   *     this.y_ = y;
   * }</pre> into two function definitions and an initialization
   * equivalent to:<pre>
   * var Point = (function () {
   *     ___.splitCtor(Point, Point_init___);
   *     function Point(var_args) {
   *       return new Point.make___(arguments);
   *     }
   *     function Point_init___(x, y) {
   *       ___.setProp(this, 'x_', x);
   *       ___.setProp(this, 'y_', y);
   *     }
   *     return Point;
   *   })();
   * </pre>
   * The result is assigned to a variable of the same name (as above) if
   * translating a declaration; the result is frozen instead if the
   * function is in expression context.
   */
  function splitCtor(constr, initer, opt_Sup, opt_name) {
    ctor(constr, opt_Sup, opt_name);
    constr.init___ = initer;
    constr.make___ = function(args) {
      this.underConstruction___ = true;
      var result = constr.init___.apply(this, args);
      delete this.underConstruction___;
      if (this.delayedTrademarks___) {
        this.trademarks___ = this.delayedTrademarks___;
        delete this.delayedTrademarks___;
      }
      // TODO(erights): The init___ method is the body of the
      // constructor, so if it returns a result s.t. (typeof result
      // === 'object' && result !== null) then we should return that
      // so that it is used as the result of the "new" operator.
      return result;
    };

    // We must preserve this identity, so anywhere that either
    // <tt>.prototype</tt> property might be assigned to, we must
    // assign to the other as well.
    constr.make___.prototype = constr.prototype;
    constr.apply = function(self, args) {
      return constr.init___.apply(self, args);
    };
    return constr;
  }

  /**
   * Enables first-class methods.
   */
  function attach(self, meth) {
    if (self === null) {
      fail('Internal: may not attach to null: ', meth);
    }
    if (self === void 0) {
      fail('Internal: may not attach to undefined: ', meth);
    }
    if (!isMethod(meth)  && !isXo4aFunc(meth)) {
      fail('Internal: attach should not see non-methods: ', meth);
    }
    if (same(meth.ATTACHMENT___, self)) {
      return meth;
    }
    if (meth.ATTACHMENT___ !== (void 0)) {
      fail('Method ', meth, ' cannot be reattached to: ', self);
    }
    function result(var_args) {
      if (!same(this, self)) {
          fail('Method ', meth, ' is already attached.\nthis: ',
               this, '\nself: ', self);
      }
      return meth.apply(self, arguments);
    }
    var result = method(result, meth.NAME___);
    result.ATTACHMENT___ = self;
    result.ORIGINAL___ = meth;
    return result;
  }

  /**
   * Marks an anonymous function as exophoric:
   * the function mentions <tt>this</tt>,
   * but only accesses the public interface.
   * <p>
   * @param opt_name if provided, should be the message name associated
   *   with the method. Currently, this is used only to generate
   *   friendlier error messages.
   */
  function xo4a(func, opt_name) {
    enforceType(func, 'function', opt_name);
    if (isCtor(func)) {
      fail("Internal: Constructors can't be exophora: ", func);
    }
    if (isSimpleFunc(func)) {
      fail("Internal: Simple functions can't be exophora: ", func);
    }
    if (isMethod(func)) {
      fail("Internal: Methods functions can't be exophora: ", func);
    }
    func.XO4A___ = true;
    return primFreeze(func);
  }

  /**
   * Mark meth as a method.
   * <p>
   * @param opt_name if provided, should be the message name associated
   *   with the method. Currently, this is used only to generate
   *   friendlier error messages.
   */
  function method(meth, opt_name) {
    enforceType(meth, 'function', opt_name);
    if (isCtor(meth)) {
      fail("Constructors can't be methods: ", meth);
    }
    if (isSimpleFunc(meth)) {
      fail("Simple functions can't be methods: ", meth);
    }
    if (isXo4aFunc(meth)) {
      fail("Internal: exophoric functions can't be methods: ", meth);
    }
    meth.METHOD___ = true;
    return primFreeze(meth);
  }

  /**
   * Mark fun as a simple function.
   * <p>
   * opt_name, if provided, should be the name of the
   * function. Currently, this is used only to generate friendlier
   * error messages.
   */
  function simpleFunc(fun, opt_name) {
    enforceType(fun, 'function', opt_name);
    if (isCtor(fun)) {
      fail("Constructors can't be simple functions: ", fun);
    }
    if (isMethod(fun)) {
      fail("Methods can't be simple function: ", fun);
    }
    if (isXo4aFunc(fun)) {
      fail("Exophoric functions can't be simple function: ", fun);
    }
    fun.SIMPLEFUNC___ = true;
    if (opt_name) {
      fun.NAME___ = String(opt_name);
    }
    return fun;  // translator freezes fun later
  }

  /**
   * Mark fun as a simple function and freeze it.
   */
  function simpleFrozenFunc(fun, opt_name) {
    return primFreeze(simpleFunc(fun, opt_name));
  }

  /** This "Only" form doesn't freeze */
  function asCtorOnly(constr) {
    if (isCtor(constr) || isSimpleFunc(constr)) {
      return constr;
    }

    enforceType(constr, 'function');
    if (isMethod(constr)) {
      fail("Methods can't be called as constructors: ", constr);
    }
    fail("Untamed functions can't be called as constructors: ", constr);
  }

  /** Only constructors and simple functions can be called as constructors */
  function asCtor(constr) {
    return primFreeze(asCtorOnly(constr));
  }

  /** Only simple functions can be called as simple functions */
  function asSimpleFunc(fun) {
    if (isSimpleFunc(fun)) {
      return fun;
    }

    enforceType(fun, 'function');
    if (isCtor(fun)) {
      if (fun === Number || fun === String || fun === Boolean) {
        // TODO(erights): To avoid accidents, <tt>method</tt>,
        // <tt>simpleFunc</tt>, and <tt>ctor</tt> each ensure that
        // these classifications are exclusive. A function can be
        // classified as in at most one of these categories. However,
        // some primordial type conversion functions like
        // <tt>String</tt> need to be invocable both ways, so we
        // should probably relax this constraint.
        // <p>
        // But before we do, we should reexamine other
        // implications. For example, simple-functions, when called
        // reflectively by <tt>call</tt> or <tt>apply</tt> (and
        // therefore <tt>bind</tt>), ignore their first argument,
        // whereas constructors can be called reflectively by
        // <tt>call</tt> to do super-initialization on behalf of a
        // derived constructor.
        // <p>
        // Curiously, ES3 also defines function behavior different
        // from constructor behavior for <tt>Object</tt>,
        // <tt>Date</tt>, <tt>RegExp</tt>, and <tt>Error</tt>. (Not
        // sure about <tt>Array</tt>.) We should understand these as
        // well before introducing a proper solution.
        return fun;
      }
      fail("Constructors can't be called as simple functions: ", fun);
    }
    if (isMethod(fun)) {
      // If it's an attached method, it can't be called on the wrong object.
      if (fun.ATTACHMENT___) {
        return fun;
      }
      fail("Methods can't be called as simple functions: ", fun);
    }
    if (isXo4aFunc(fun)) {
      fail("Exophoric functions can't be called as simple functions: ", fun);
    }
    fail("Untamed functions can't be called as simple functions: ", fun);
  }

  /**
   * Only simple and exophoric functions can be called as exophoric
   * functions.
   */
  function asXo4aFunc(fun) {
    if (isXo4aFunc(fun)) {
      return fun;
    }
    return asSimpleFunc(fun);
  }

  /**
   * Returns true if the object is known to be the prototype of some
   * other object.
   * <p>
   * May give false negatives, but won't give false positives.
   */
  function isPrototypical(o) {
    if (typeof o !== 'object') { return false; }
    var c = o.constructor;
    if (typeof c !== 'function') { return false; }
    return c.prototype === o;
  }

  /**
   * Throws an exception if the value is an unmarked function or a
   * prototypical object.
   */
  function asFirstClass(value) {
    switch(typeof value) {
      case 'function': {
        if (((isMethod(value) ||
              isSimpleFunc(value) ||
              isXo4aFunc(value) ||
              isCtor(value)) &&
             isFrozen(value)) ||
            isInstanceOf(value, RegExp)) {
          return value;
        } else {
          // TODO(metaweta): make this a caja-uncatchable exception
          fail('Internal: toxic function encountered: ', value);
        }
        break;
      }
      case 'object': {
        if (value !== null && isPrototypical(value)) {
          // TODO(metaweta): make this a caja-uncatchable exception
          fail('Internal: prototypical object encountered: ', value);
        }
        return value;
      }
      default: {
        return value;
      }
    }
  }

  /**
   * Sets constr.prototype[name] = member.
   * <p>
   * If member is a method of constr, make it callable.
   * If member is a simple function, make it callable and readable.
   * Else make it readable.
   */
  function setMember(constr, name, member) {
    name = String(name);
    if (endsWith__.test(name) || name === 'valueOf' || name === 'constructor') {
      fail('Reserved name: ', name);
    }
    var proto = asCtorOnly(constr).prototype;
    // We allow prototype members to end in a single "_".
    if (!canSetProp(proto, name)) {
      if (name === 'toString') {
        proto.handleSet___('toString', member);
        return;
      }
      fail('not settable: ', name);
    }
    if (isMethod(member) || isXo4aFunc(member)) {
      fastpathCall(proto, name);
      fastpathEnumOnly(proto, name);
    } else if (isSimpleFunc(member)) {
      fastpathCall(proto, name);
      fastpathEnumOnly(proto, name);
      fastpathRead(proto, name);
    } else {
      fastpathEnumOnly(proto, name);
      fastpathRead(proto, name);
    }
    proto[name] = asFirstClass(member);
  }

  ////////////////////////////////////////////////////////////////////////
  // Accessing properties
  ////////////////////////////////////////////////////////////////////////

  /**
   * Can a constructed Caja object read this property on itself?
   * <p>
   * Can a Caja method whose <tt>this</tt> is bound to <tt>self</tt>
   * read its own <tt>name</tt> property? For properties added to
   * the object by Caja code, the answer is yes. For other
   * properties, which must therefore be inherited from a prototype
   * written in Javascript rather than Caja, the answer is: iff they
   * were whitelisted.
   */
  function canReadProp(self, name) {
    name = String(name);
    if (endsWith__.test(name)) { return false; }
    return canRead(self, name);
  }

  /**
   * A constructed Caja object's attempt to read this property on
   * itself.
   * <p>
   * If it can't,  it reads <tt>undefined</tt> instead.
   */
  function readProp(self, name) {
    if ((typeof name) === 'number') { return self[name]; }
    name = String(name);
    if (canReadProp(self, name)) { return self[name]; }
    if (canCall(self, name)) { return attach(self, self[name]); }
    return self.handleRead___(name, false);
  }

  /**
   * Can a Caja client of <tt>obj</tt> read its <name> property?
   * <p>
   * If the property is Internal (i.e. ends in an '_'), then no.
   * If the property was defined by Caja code, then yes. If it was
   * whitelisted, then yes. Or if the property is an own property of
   * a JSON container, then yes.
   */
  function canReadPub(obj, name) {
    name = String(name);
    if (endsWith_.test(name)) { return false; }
    if (obj === null) { return false; }
    if (obj === void 0) { return false; }
    if (canRead(obj, name)) { return true; }
    if (name === 'toString') { return false; }
    if (!isJSONContainer(obj)) { return false; }
    if (!hasOwnProp(obj, name)) { return false; }
    fastpathRead(obj, name);
    return true;
  }

  /**
   * Implements <tt>name in obj</tt>
   */
  function inPub(name, obj) {
    if (obj === null || obj === void 0) {
      return name in obj; // force the stock error
    }
    obj = Object(obj);
    if (canReadPub(obj, name)) {
      return true;
    }
    if (canCallPub(obj, name)) {
      return true;
    }
    var handlerName = name + '_getter___';
    if (handlerName in obj) {
      return true;
    }
    handlerName = name + '_handler___';
    if (handlerName in obj) {
      return true;
    }
    return false;
  }

  /**
   * Caja code attempting to read a property on something besides
   * <tt>this</tt>.
   * <p>
   * If it can't then <tt>readPub</tt> returns <tt>undefined</tt>
   * instead.
   */
  function readPub(obj, name) {
    if ((typeof name) === 'number') {
      if (typeof obj === 'string') {
        // In partial anticipation of ES3.1. 
        // TODO(erights): Once ES3.1 settles, revisit this and 
        // correctly implement the agreed semantics.
        // Mike Samuel suggests also making it conditional on
        //  (+name) === (name & 0x7fffffff)
        return obj.charAt(name);
      } else {
        return obj[name]; 
      }
    }
    name = String(name);
    if (canReadPub(obj, name)) { return obj[name]; }
    if (canCallPub(obj, name)) { return attach(obj, obj[name]); }
    return obj.handleRead___(name);
  }

  /**
   * Ensure that all the permitsUsed starting at result are forever
   * safe to allow without runtime checks.
   */
  function enforceStaticPath(result, permitsUsed) {
    each(permitsUsed, simpleFrozenFunc(function(name, subPermits) {
      // Don't factor out since we don't enforce frozen if permitsUsed
      // are empty. 
      // TODO(erights): Once we have ES3.1ish attribute control, it
      // will suffice to enforce that each used property is frozen
      // independent of the object as a whole.
      enforce(isFrozen(result), 'Assumed frozen: ', result);
      if (name === '()') {
        // TODO(erights): Revisit this case
      } else {
        enforce(canReadPub(result, name),
                'Assumed readable: ', result, '.', name);
        if (inPub('()', subPermits)) {
          enforce(canCallPub(result, name),
                  'Assumed callable: ', result, '.', name, '()');
        }
        enforceStaticPath(readPub(result, name), subPermits);
      }
    }));
  }

  /**
   * Privileged code attempting to read an imported value from a module's
   * <tt>IMPORTS___</tt>. This function is NOT available to Caja code.
   * <p>
   * This delegates to <tt>readPub</tt>.
   * TODO(ihab.awad): Make this throw a "module linkage error" so as to be
   * more informative, rather than just whatever readPub throws.
   */
  function readImport(module_imports, name, opt_permitsUsed) {
    var result;
    if ((typeof name) === 'number') { 
      result = module_imports[name]; 
    } else {
      result = readPub(module_imports, name);
    }
    if (opt_permitsUsed) {
      enforceStaticPath(result, opt_permitsUsed);
    }
    return result;
  }

  /**
   * Can "innocent" code enumerate the named property on this object?
   * <p>
   * "Innocent" code is code which we assume to be ignorant of Caja,
   * not to be actively hostile, but which may be buggy (and
   * therefore accidentally harmful or exploitable). This
   * corresponds to legacy code, such as libraries, that we decide
   * to run untranslated, perhaps hidden or tamed, but which needs
   * to co-exist smoothly with the Caja runtime.
   * <p>
   * An earlier version of canInnocentEnum() filtered out exactly those
   * names ending with a double underbar. It now filters out exactly
   * those names ending in a triple underbar. Caja code can't see names
   * ending in a double underbar, since existing platforms (like
   * Firefox) use such names for purposes that should be hidden from
   * Caja code. However, it is not up to Caja to shield innocent code
   * from seeing such platform properties. All the magic names Caja
   * adds for its own internal bookkeeping end in triple underbar, so
   * that is all we need to hide from innocent code.
   */
  function canInnocentEnum(obj, name) {
    name = String(name);
    if (endsWith___.test(name)) { return false; }
    return true;
  }

  /**
   * Would a Caja for/in loop on <tt>this</tt> see this name?
   * <p>
   * For properties defined in Caja, this is generally the same as
   * canReadProp. Otherwise according to whitelisting.
   */
  function canEnumProp(self, name) {
    name = String(name);
    if (endsWith__.test(name)) { return false; }
    return canEnum(self, name);
  }

  /**
   * Would a Caja for/in loop by a client of obj see this name?
   * <p>
   * For properties defined in Caja, this is generally the same as
   * canReadProp. Otherwise according to whitelisting.
   */
  function canEnumPub(obj, name) {
    name = String(name);
    if (endsWith_.test(name)) { return false; }
    if (canEnum(obj, name)) { return true; }
    if (!isJSONContainer(obj)) { return false; }
    if (!hasOwnProp(obj, name)) { return false; }
    fastpathEnumOnly(obj, name);
    if (name === 'toString') { return true; }
    fastpathRead(obj, name);
    return true;
  }

  /**
   * Like canEnumPub, but allows only non-inherited properties.
   */
  function canEnumOwn(obj, name) {
    name = String(name);
    return hasOwnProp(obj, name) && canEnumPub(obj, name);
  }

  /**
   * Returns a new object whose only utility is its identity and (for
   * diagnostic purposes only) its name.
   */
  function Token(name) {
    name = String(name);
    return primFreeze({
          toString: simpleFrozenFunc(function() { return name; })
        });
  }
  simpleFrozenFunc(Token);

  /**
   * Inside a <tt>caja.each()</tt>, the body function can terminate
   * early, as if with a conventional <tt>break;</tt>, by doing a
   * <pre>return caja.BREAK;</pre>
   */
  var BREAK = Token('BREAK');

  /**
   * For each sensible key/value pair in obj, call fn with that
   * pair.
   * <p>
   * If obj is an array, then enumerate indexes. Otherwise, enumerate
   * the canEnumOwn() property names. 
   */
  function each(obj, fn) {
    fn = asSimpleFunc(fn);
    if (isArray(obj)) {
      var len = obj.length;
      for (var i = 0; i < len; i++) {
        if (fn(i, readPub(obj, i)) === BREAK) {
          return;
        }
      }
    } else {
      for (var k in obj) {
        if (canEnumOwn(obj, k)) {
          if (fn(k, readPub(obj, k)) === BREAK) {
            return;
          }
        }
      }
    }
  }

  /**
   * Can this be called as an internal method?
   * <p>
   * For genuine methods, they are only callable if the canCall
   * attribute is set. Otherwise, if this property is readable and
   * holds a simple function, then it's also callable as a function,
   * which we can memoize.
   */
  function canCallProp(self, name) {
    name = String(name);
    if (endsWith__.test(name)) { return false; }
    if (canCall(self, name)) { return true; }
    if (!canReadProp(self, name)) { return false; }
    if (name === 'toString') { return false; }
    var func = self[name];
    if (!isSimpleFunc(func)) { return false; }
    fastpathCall(self, name);
    return true;
  }

  /**
   * A Caja method tries to call one of its Internal methods.
   */
  function callProp(self, name, args) {
    name = String(name);
    if (canCallProp(self, name)) {
      var meth = self[name];
      return meth.apply(self, args);
    } else {
      return self.handleCall___(name, args);
    }
  }

  /**
   * Like canCallProp(), with differences that parallel the
   * differences between canReadProp() vs canReadPub().
   */
  function canCallPub(obj, name) {
    name = String(name);
    if (endsWith_.test(name)) { return false; }
    if (obj === null) { return false; }
    if (obj === void 0) { return false; }
    if (canCall(obj, name)) { return true; }
    if (!canReadPub(obj, name)) { return false; }
    if (name === 'toString') { return false; }
    var func = obj[name];
    if (!isSimpleFunc(func) && !isXo4aFunc(func) && !isMethod(func)) {
      return false;
    }
    fastpathCall(obj, name);
    return true;
  }

  /**
   * A client of obj tries to call one of its methods.
   */
  function callPub(obj, name, args) {
    name = String(name);
    if (canCallPub(obj, name)) {
      var meth = obj[name];
      return meth.apply(obj, args);
    }
    if (obj.handleCall___) { return obj.handleCall___(name, args); }
    fail('not callable:', debugReference(obj), '.', name);
  }

  /**
   * Can a method of a Caja constructed object directly assign to
   * this property of its object?
   * <p>
   * Only if this object is not frozen.
   */
  function canSetProp(self, name) {
    name = String(name);
    if (endsWith__.test(name)) { return false; }
    if (canSet(self, name)) { return true; }
    if (name === 'valueOf') { return false; }
    if (name === 'toString') { return false; }
    return !isFrozen(self);
  }

  /**
   * A Caja method tries to assign to this property of its object.
   */
  function setProp(self, name, val) {
    name = String(name);
    if (canSetProp(self, name)) {
      fastpathSet(self, name);
      if (!hasOwnProp(self, name)) {
        fastpathDelete(self, name);
      }
      return self[name] = asFirstClass(val);
    } else {
      return self.handleSet___(name, val);
    }
  }

  /**
   * Can a client of obj directly assign to its name property?
   * <p>
   * If this property is Internal (i.e., ends with a '_') or if this
   * object is frozen, then no.
   * If this property is not Internal and was defined by Caja code,
   * then yes. If the object is a JSON container, then
   * yes. Otherwise according to whitelisting decisions.
   * <p>
   * The non-obvious implication of this rule together with the
   * canSetProp rule is that a Caja client of a Caja constructed
   * object cannot add new properties to it. But a Caja constructed
   * object can add new properties to itself, and its clients can
   * then assign to these properties.
   */
  function canSetPub(obj, name) {
    name = String(name);
    if (endsWith_.test(name)) { return false; }
    if (canSet(obj, name)) { return true; }
    if (name === 'valueOf') { return false; }
    if (name === 'toString') { return false; }
    return !isFrozen(obj) && isJSONContainer(obj);
  }

  /** A client of obj attempts to assign to one of its properties. */
  function setPub(obj, name, val) {
    name = String(name);
    if (canSetPub(obj, name)) {
      fastpathSet(obj, name);
      return obj[name] = asFirstClass(val);
    } else {
      return obj.handleSet___(name, val);
    }
  }

  /**
   * Can the given constructor have the given static method added to it?
   * @param {Function} ctor
   * @param {string} staticMemberName an identifier in the public namespace.
   */
  function canSetStatic(ctor, staticMemberName) {
    staticMemberName = '' + staticMemberName;
    if (typeof ctor !== 'function') {
      log('Cannot set static member of non function', ctor);
      return false;
    }
    if (isFrozen(ctor)) {
      log('Cannot set static member of frozen function', ctor);
      return false;
    }
    // disallows prototype, call, apply, bind
    if (staticMemberName in ctor) {
      log('Cannot override static member ', staticMemberName);
      return false;
    }
    // statics are public
    if (endsWith_.test(staticMemberName) || staticMemberName === 'valueOf') {
      log('Illegal static member name ', staticMemberName);
      return false;
    }
    if (staticMemberName === 'toString') {
      // no diagnostic as this is a normal fault-handling case.
      return false;
    }
    return true;
  }

  /**
   * Sets a static members of a ctor, making sure that it can't be used to
   * override call/apply/bind and other builtin members of function.
   * @param {Function} ctor
   * @param {string} staticMemberName an identifier in the public namespace.
   * @param staticMemberValue the value of the static member.
   */
  function setStatic(ctor, staticMemberName, staticMemberValue) {
    staticMemberName = '' + staticMemberName;
    if (canSetStatic(ctor, staticMemberName)) {
      ctor[staticMemberName] = staticMemberValue;
      fastpathEnumOnly(ctor, staticMemberName);
      fastpathRead(ctor, staticMemberName);
    } else {
      ctor.handleSet___(staticMemberName, staticMemberValue);
    }
  }

  /**
   * Can a Caja constructed object delete the named property?
   */
  function canDeleteProp(obj, name) {
    name = String(name);
    if (isFrozen(obj)) { return false; }
    if (endsWith__.test(name)) { return false; }
    if (name === 'valueOf') { return false; }
    if (name === 'toString') { return false; }
    if (isJSONContainer(obj)) { return true; }
    return !!obj[name + '_canDelete___'];
  }

  /**
   * A Caja constructed object attempts to delete one of its own
   * properties.
   */
  function deleteProp(obj, name) {
    name = String(name);
    if (canDeleteProp(obj, name)) {
      // See deleteFieldEntirely for reasons why we don't cache deletability.
      return deleteFieldEntirely(obj, name);
    } else {
      return obj.handleDelete___(name);
    }
  }

  /**
   * Can a client of obj delete the named property?
   */
  function canDeletePub(obj, name) {
    name = String(name);
    if (isFrozen(obj)) { return false; }
    if (endsWith_.test(name)) { return false; }
    if (name === 'valueOf') { return false; }
    if (name === 'toString') { return false; }
    if (isJSONContainer(obj)) { return true; }
    return false;
  }

  /**
   * A client of obj can only delete a property of obj if obj is a
   * non-frozen JSON container.
   */
  function deletePub(obj, name) {
    name = String(name);
    if (canDeletePub(obj, name)) {
      // See deleteFieldEntirely for reasons why we don't cache deletability.
      return deleteFieldEntirely(obj, name);
    } else {
      return obj.handleDelete___(name);
    }
  }

  /**
   * Deletes a field removing any cached permissions.
   * @param {object} obj
   * @param {string} name of field in obj to delete.
   * @return {boolean}
   * @throws {Error} if field not deletable or name not in field.
   * @private
   */
  function deleteFieldEntirely(obj, name) {
    // Can't cache fastpath delete since deleting the field should remove
    // all privileges for that field.
    delete obj[name + '_canRead___'];
    delete obj[name + '_canEnum___'];
    delete obj[name + '_canCall___'];
    delete obj[name + '_grantCall___'];
    delete obj[name + '_grantSet___'];
    delete obj[name + '_canSet___'];
    delete obj[name + '_canDelete___'];
    return (delete obj[name]) || (fail('not deleted: ', name), false);
  }

  ////////////////////////////////////////////////////////////////////////
  // Other
  ////////////////////////////////////////////////////////////////////////

  /**
   * This returns a frozen array copy of the original array or
   * array-like object.
   * <p>
   * If a Caja program makes use of <tt>arguments</tt> in any
   * position other than <tt>arguments.callee</tt>, this is
   * rewritten to use a frozen array copy of arguments instead. This
   * way, if Caja code passes its arguments to someone else, they
   * are not giving the receiver the rights to access the passing
   * function nor to modify the parameter variables of the passing
   * function.
   */
  function args(original) {
    return primFreeze(Array.slice(original, 0));
  }

  /**
   * When a <tt>this</tt> value must be provided but nothing is
   * suitable, provide this useless object instead.
   */
  var USELESS = Token('USELESS');

  /**
   * A call to caja.manifest(data) is dynamically ignored, but if the
   * data expression is valid static JSON text, its value is made
   * statically available to the module loader. 
   */
  function manifest(ignored) {}

  /** Sealer for call stacks as from {@code (new Error).stack}. */
  var callStackSealer = makeSealerUnsealerPair();

  /**
   * Receives the exception caught by a user defined catch block.
   * @param ex a value caught in a try block.
   * @return a tamed exception.
   */
  function tameException(ex) {
    try {
      switch (typeof ex) {
        case 'object': {
          if (ex === null) { return null; }
          if (isInstanceOf(ex, Error)) {
            // See Ecma-262 S15.11 for the definitions of these properties.
            var message = ex.message || ex.desc;
            var stack = ex.stack;
            var name = ex.constructor && ex.constructor.name;  // S15.11.7.9
            // Convert to undefined if falsy, or a string otherwise.
            message = !message ? void 0 : '' + message;
            stack = !stack ? void 0 : callStackSealer.seal('' + stack);
            name = !name ? void 0 : '' + name;
            return primFreeze({ message: message, name: name, stack: stack });
          }
          return '' + ex;
        }
        case 'string':
        case 'number':
        case 'boolean':
        case 'undefined': {
          // Immutable.
          return ex;
        }
        case 'function': {
          // According to Pratap Lakhsman's "JScript Deviations" S2.11
          // If the caught object is a function, calling it within the catch
          // supplies the head of the scope chain as the "this value".  The
          // called function can add properties to this object.  This implies
          // that for code of this shape:
          //     var x;
          //     try {
          //       // ...
          //     } catch (E) {
          //       E();
          //       return s;
          //     }
          // The reference to 'x' within the catch is not necessarily to the
          // local declaration of 'x'; this gives Catch the same performance
          // problems as with.

          // We return undefined to make sure that caught functions cannot be
          // evaluated within the catch block.
          return void 0;
        }
        default: {
          log('Unrecognized exception type ' + (typeof ex));
          return void 0;
        }
      }
    } catch (_) {
      // Can occur if coercion to string fails, or if ex has getters
      // that fail.  This function must never throw an exception
      // because doing so would cause control to leave a catch block
      // before the handler fires.
      return void 0;
    }
  }

  /**
   *
   */
  function setMemberMap(sub, members) {
    each(members, simpleFrozenFunc(function(mname, member) {
      setMember(sub, mname, member);
    }));
  }

  /**
   * Makes a new empty object that directly inherits from parent.
   */
  function primBeget(proto) {
    function F() {}
    F.prototype = proto;
    var result = new F();
    result.proto___ = proto;
    return result;
  }

  /**
   * Provides a shorthand for a class-like declaration of a fresh
   * Caja constructor.
   * <p>
   * Given that sub is a Caja constructor in formation, whose 'prototype'
   * property hasn't been initialized yet, initialize sub and its
   * 'prototype' property so that it acts as a subclass of opt_Sup,
   * with opt_members added as members to sub.prototype, and
   * opt_statics added as members to sub.
   * <p>
   * TODO(erights): return a builder object that allows further
   * initialization.
   */
  function commonDef(init) {
    return function(sub, opt_Sup, opt_members, opt_statics) {
      var sup = opt_Sup || Object;
      // TODO(metaweta): Fix caja.def here or in the rewrite rule to
      // avoid creating an object literal with a bad toString member
      // that gets executed by Firebug when printing stack info during
      // an error.
      var members = opt_members || {};
      var statics = opt_statics || {};

      if (isSimpleFunc(sub)) {
        derive(sub, sup);
      } else {
        ctor(sub, sup);
      }
      sub.prototype = primBeget(sup.prototype);
      if (sub.make___) {
        // We must preserve this identity, so anywhere that either
        // <tt>.prototype</tt> property might be assigned to, we must
        // assign to the other as well.
        sub.make___.prototype = sub.prototype;
      }
      sub.prototype.constructor = sub;
      init(sub, members);
      each(statics, simpleFrozenFunc(function(sname, staticMember) {
        setStatic(sub, sname, staticMember);
      }));
      // translator freezes sub and sub.prototype later.
    };
  }

  var def = commonDef(setMemberMap);

  /**
   *
   * Unsafe version of <tt>caja.def</tt> for use by uncajoled code.
   */
  var unsafeDef = commonDef(
      function (sub, members) {
        each(members, simpleFrozenFunc(function(key, val){
          sub.prototype[key] = val;
        }));
      });

  ////////////////////////////////////////////////////////////////////////
  // Taming mechanism
  ////////////////////////////////////////////////////////////////////////

  /**
   * Arrange to handle read-faults on <tt>obj[name]</tt>
   * by calling <tt>getHandler()</tt> as a method on
   * the faulted object.
   * <p>
   * In order for this fault-handler to get control, it's important
   * that no one does a conflicting <tt>grantRead()</tt>.
   * FIXME(ben): and fastpathRead()?
   */
  function useGetHandler(obj, name, getHandler) {
    obj[name + '_getter___'] = getHandler;
  }

  /**
   * Arrange to handle call-faults on <tt>obj[name](args...)</tt> by
   * calling <tt>applyHandler(args)</tt> as a method on the faulted
   * object.
   * <p>
   * Note that <tt>applyHandler</tt> is called with a single argument,
   * which is the list of arguments in the original call.
   * <p>
   * In order for this fault-handler to get control, it's important
   * that no one does a conflicting grantCall() or other grants which
   * imply grantCall().
   * FIXME(ben): also fastpath?
   */
  function useApplyHandler(obj, name, applyHandler) {
    obj[name + '_handler___'] = applyHandler;
  }

  /**
   * Arrange to handle call-faults on <tt>obj[name](args...)</tt> by
   * calling <tt>callHandler(args...)</tt> as a method on the faulted
   * object.
   * <p>
   * Note that <tt>callHandler</tt> is called with the same arguments
   * as the original call.
   * <p>
   * In order for this fault-handler to get control, it's important
   * that no one does a conflicting grantCall() or other grants which
   * imply grantCall().
   * FIXME(ben): also fastpath?
   */
  function useCallHandler(obj, name, callHandler) {
    useApplyHandler(obj, name, function(args) {
      return callHandler.apply(this, args);
    });
  }

  /**
   * Arrange to handle set-faults on <tt>obj[name] = newValue</tt> by
   * calling <tt>setHandler(newValue)</tt> as a method on the faulted
   * object.
   * <p>
   * In order for this fault-handler to get control, it's important
   * that no one does a conflicting grantSet().
   * FIXME(ben): also fastpath?
   */
  function useSetHandler(obj, name, setHandler) {
    obj[name + '_setter___'] = setHandler;
  }

  /**
   * Arrange to handle delete-faults on <tt>delete obj[name]</tt> by
   * calling <tt>deleteHandler()</tt> as a method on the faulted object.
   * <p>
   * In order for this fault-handler to get control, it's important
   * that no one does a conflicting grantDelete().
   * FIXME(ben): also fastpath?
   */
  function useDeleteHandler(obj, name, deleteHandler) {
    obj[name + '_deleter___'] = deleteHandler;
  }

  /**
   * Whilelist obj[name] as a simple frozen function that can be either
   * called or read.
   */
  function grantSimpleFunc(obj, name) {
    simpleFrozenFunc(obj[name], name);
    grantCall(obj, name);
    grantRead(obj, name);
  }

  /**
   * Whitelist proto[name] as a generic method that can safely be
   * called with its <tt>this</tt> bound to other objects.
   * <p>
   * TODO(erights): Once we retire Original-Caja, the result of
   * extracting a generic method should be disfunction-like rather than
   * an exophoric function. We should remove any remaining notions of
   * exophoric behavior from Cajita.
   */
  function grantGeneric(proto, name) {
    xo4a(proto[name], name);
    grantCall(proto, name);
    grantRead(proto, name);
  }

  /**
   * Mark func as exophoric (for now) and use it as a virtual generic
   * method by installing appropriate get and call handlers.
   * <p>
   * TODO(erights): Once we retire Original-Caja, the result of
   * extracting a generic method should be disfunction-like rather than
   * an exophoric function. We should remove any remaining notions of
   * exophoric behavior from Cajita.
   */
  function handleGeneric(obj, name, func) {
    xo4a(func);
    useGetHandler(obj, name, function() { return func; });
    useCallHandler(obj, name, func);
  }

  /**
   * Virtually replace proto[name] with a fault-handler
   * wrapper that first verifies that <tt>this</tt> inherits from
   * proto. 
   * <p>
   * When a pre-existing Javascript method may do something unsafe
   * when applied to a <tt>this</tt> of the wrong type, we need to
   * provide a fault-handler instead to prevent such mis-application.
   * <p>
   * In order for this fault handler to get control, it's important
   * that no one does an grantCall() or other grants which imply
   * grantCall(). 
   * FIXME(ben): also fastpath?
   */
  function grantTypedGeneric(proto, name) {
    var original = proto[name];
    handleGeneric(proto, name, function(var_args) {
      if (!inheritsFrom(this, proto)) {
        fail("Can't call .", name, ' on a non ',
             directConstructor(proto), ': ', this);
      }
      return original.apply(this, arguments);
    });
  }

  /**
   * Virtually replace proto[name] with a fault-handler
   * wrapper that first verifies that <tt>this</tt> isn't frozen.
   * <p>
   * When a pre-existing Javascript method would mutate its object,
   * we need to provide a fault handler instead to prevent such
   * mutation from violating Caja semantics. 
   * <p>
   * In order for this fault handler to get control, it's important
   * that no one does an grantCall() or other grants which imply
   * grantCall(). 
   * FIXME(ben): also fastpath?
   */
  function grantMutator(proto, name) {
    var original = proto[name];
    handleGeneric(proto, name, function(var_args) {
      if (isFrozen(this)) {
        fail("Can't .", name, ' a frozen object');
      }
      return original.apply(this, arguments);
    });
  }

  /**
   * Whitelist proto[name] as a method that can be called on objects
   * that inherit from proto. 
   * <p>
   * Methods whitelisted using grantMethod() are attached to their
   * instance on extraction. To ensure attachment on extraction, do
   * not grantRead() or any other grant which implies grantRead().
   */
  function grantMethod(proto, name) {
    method(proto[name], name);
    grantCall(proto, name);
  }

  /**
   * Verifies that regexp is something that can appear as a
   * parameter to a Javascript method that would use it in a match.
   * <p>
   * If it is a RegExp, then this match might mutate it, which must
   * not be allowed if regexp is frozen. Otherwise it must be a string.
   */
  function enforceMatchable(regexp) {
    if (isInstanceOf(regexp, RegExp)) {
      if (isFrozen(regexp)) {
        fail("Can't match with frozen RegExp: ", regexp);
      }
    } else {
      enforceType(regexp, 'string');
    }
  }

  /**
   * A shorthand that happens to be useful here.
   * <p>
   * For all i in arg2s: func2(arg1,arg2s[i]).
   */
  function all2(func2, arg1, arg2s) {
    var len = arg2s.length;
    for (var i = 0; i < len; i += 1) {
      func2(arg1, arg2s[i]);
    }
  }

  ////////////////////////////////////////////////////////////////////////
  // Taming decisions
  ////////////////////////////////////////////////////////////////////////

  /// Math

  all2(grantRead, Math, [
    'E', 'LN10', 'LN2', 'LOG2E', 'LOG10E', 'PI', 'SQRT1_2', 'SQRT2'
  ]);
  all2(grantSimpleFunc, Math, [
    'abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor',
    'log', 'max', 'min', 'pow', 'random', 'round', 'sin', 'sqrt', 'tan'
  ]);

  /// toString

  function grantToString(proto) {
    proto.TOSTRING___ = xo4a(proto.toString, 'toString');
  }
  useGetHandler(Object.prototype, 'toString', function() {
    if (hasOwnProp(this, 'toString') && 
        typeof this.toString === 'function' &&
        !hasOwnProp(this, 'TOSTRING___')) {
      // This case is a kludge that doesn't work for undiagnosed reasons.
//    this.TOSTRING___ = xo4a(this.toString, 'toString');
      // TODO(erights): This case is a different kludge that needs to
      // be explained.
      return this.toString;
    }
    return this.TOSTRING___;
  });
  useApplyHandler(Object.prototype, 'toString', function(args) {
    return this.toString.apply(this, args); 
  });
  useSetHandler(Object.prototype, 'toString', function(meth) {
    if (isFrozen(this)) {
      return myKeeper.handleSet(this, 'toString', meth);
    }
    meth = asFirstClass(meth);
    this.TOSTRING___ = meth;
    this.toString = function(var_args) {
      var args = Array.slice(arguments, 0);
      if (typeof meth === 'function') {
        return meth.apply(this, args);
      }
      var methApply = readPub(meth, 'apply');
      if (typeof methApply === 'function') {
        return methApply.call(meth, this, args);
      }
      var result = Object.toString.call(this);
      log('Not correctly printed: ' + result);
      return result;
    };
    return meth;
  });
  useDeleteHandler(Object.prototype, 'toString', function() {
    if (isFrozen(this)) {
      return myKeeper.handleDelete(this, 'toString');
    }
    return (delete this.toString) && (delete this.TOSTRING___);
  });
  
  /// Object

  ctor(Object, (void 0), 'Object');
  grantToString(Object.prototype);
  all2(grantGeneric, Object.prototype, [
    'toLocaleString', 'valueOf', 'isPrototypeOf'
  ]);
  grantRead(Object.prototype, 'length');
  handleGeneric(Object.prototype, 'hasOwnProperty', function(name){
    name = String(name);
    return canReadPub(this, name) && hasOwnProp(this, name);
  });
  handleGeneric(Object.prototype, 'propertyIsEnumerable', function(name) {
    name = String(name);
    return canEnumPub(this, name);
  });

  /// Function

  handleGeneric(Function.prototype, 'apply', function(self, realArgs) {
    return asXo4aFunc(this).apply(self, realArgs);
  });
  handleGeneric(Function.prototype, 'call', function(self, var_args) {
    return asXo4aFunc(this).apply(self, Array.slice(arguments, 1));
  });
  handleGeneric(Function.prototype, 'bind', function(self, var_args) {
    var thisFunc = this;
    var leftArgs = Array.slice(arguments, 1);
    return simpleFrozenFunc(function(var_args) {
      var args = leftArgs.concat(Array.slice(arguments, 0));
      return callPub(thisFunc, 'apply', [self, args]);
    });
  });

  /// Array

  ctor(Array, Object, 'Array');
  grantSimpleFunc(Array, 'slice');
  grantToString(Array.prototype);
  all2(grantTypedGeneric, Array.prototype, [ 'toLocaleString' ]);
  all2(grantGeneric, Array.prototype, [
    'concat', 'join', 'slice', 'indexOf', 'lastIndexOf'
  ]);
  all2(grantMutator, Array.prototype, [
    'pop', 'push', 'reverse', 'shift', 'splice', 'unshift'
  ]);
  handleGeneric(Array.prototype, 'sort', function(comparator) {
    if (isFrozen(this)) {
      fail("Can't sort a frozen array.");
    }
    if (comparator) {
      return Array.prototype.sort.call(this, ___.asSimpleFunc(comparator));
    } else {
      return Array.prototype.sort.call(this);
    }
  });

  /// String

  ctor(String, Object, 'String');
  grantSimpleFunc(String, 'fromCharCode');
  grantToString(String.prototype);
  all2(grantTypedGeneric, String.prototype, [
    'toLocaleString', 'indexOf', 'lastIndexOf'
  ]);
  all2(grantGeneric, String.prototype, [
    'charAt', 'charCodeAt', 'concat', 
    'localeCompare', 'slice', 'substr', 'substring',
    'toLowerCase', 'toLocaleLowerCase', 'toUpperCase', 'toLocaleUpperCase'
  ]);

  handleGeneric(String.prototype, 'match', function(regexp) {
    enforceMatchable(regexp);
    return this.match(regexp);
  });
  handleGeneric(String.prototype, 'replace', function(searcher, replacer) {
    enforceMatchable(searcher);
    return this.replace(
            searcher,
            (typeof replacer === 'function'
             ? ___.asSimpleFunc(replacer)
             : '' + replacer));
  });
  handleGeneric(String.prototype, 'search', function(regexp) {
    enforceMatchable(regexp);
    return this.search(regexp);
  });
  handleGeneric(String.prototype, 'split', function(separator, limit) {
    enforceMatchable(separator);
    return this.split(separator, limit);
  });

  /// Boolean

  ctor(Boolean, Object, 'Boolean');
  grantToString(Boolean.prototype);

  /// Number

  ctor(Number, Object, 'Number');
  all2(grantRead, Number, [
    'MAX_VALUE', 'MIN_VALUE', 'NaN',
    'NEGATIVE_INFINITY', 'POSITIVE_INFINITY'
  ]);
  grantToString(Number.prototype);
  all2(grantTypedGeneric, Number.prototype, [
    'toFixed', 'toExponential', 'toPrecision'
  ]);

  /// Date

  ctor(Date, Object, 'Date');
  grantSimpleFunc(Date, 'parse');
  grantSimpleFunc(Date, 'UTC');
  grantToString(Date.prototype);
  all2(grantTypedGeneric, Date.prototype, [
    'toDateString','toTimeString', 'toUTCString',
    'toLocaleString', 'toLocaleDateString', 'toLocaleTimeString',
    'toISOString',
    'getDay', 'getUTCDay', 'getTimezoneOffset',

    'getTime', 'getFullYear', 'getUTCFullYear', 'getMonth', 'getUTCMonth',
    'getDate', 'getUTCDate', 'getHours', 'getUTCHours',
    'getMinutes', 'getUTCMinutes', 'getSeconds', 'getUTCSeconds',
    'getMilliseconds', 'getUTCMilliseconds'
  ]);
  all2(grantMutator, Date.prototype, [
    'setTime', 'setFullYear', 'setUTCFullYear', 'setMonth', 'setUTCMonth',
    'setDate', 'setUTCDate', 'setHours', 'setUTCHours',
    'setMinutes', 'setUTCMinutes', 'setSeconds', 'setUTCSeconds',
    'setMilliseconds', 'setUTCMilliseconds'
  ]);

  /// RegExp

  ctor(RegExp, Object, 'RegExp');
  grantToString(RegExp.prototype);  
  handleGeneric(RegExp.prototype, 'exec', function(specimen) {
    if (isFrozen(this)) {
      fail("Can't .exec a frozen RegExp");
    }
    specimen = String(specimen); // See bug 528
    return this.exec(specimen);
  });
  handleGeneric(RegExp.prototype, 'test', function(specimen) {
    if (isFrozen(this)) {
      fail("Can't .test a frozen RegExp");
    }
    specimen = String(specimen); // See bug 528
    return this.test(specimen);
  });

  all2(grantRead, RegExp.prototype, [
    'source', 'global', 'ignoreCase', 'multiline', 'lastIndex'
  ]);

  /// errors

  ctor(Error, Object, 'Error');
  grantToString(Error.prototype);
  grantRead(Error.prototype, 'name');
  grantRead(Error.prototype, 'message');
  ctor(EvalError, Error, 'EvalError');
  ctor(RangeError, Error, 'RangeError');
  ctor(ReferenceError, Error, 'ReferenceError');
  ctor(SyntaxError, Error, 'SyntaxError');
  ctor(TypeError, Error, 'TypeError');
  ctor(URIError, Error, 'URIError');


  var sharedImports;

  ////////////////////////////////////////////////////////////////////////
  // Module loading
  ////////////////////////////////////////////////////////////////////////

  var myNewModuleHandler;

  /**
   * Gets the current module handler.
   */
  function getNewModuleHandler() {
    return myNewModuleHandler;
  }

  /**
   * Registers a new-module-handler, to be called back when a new
   * module is loaded.
   * <p>
   * This callback mechanism is provided so that translated Caja
   * modules can be loaded from a trusted site with the
   * &lt;script&gt; tag, which runs its script as a statement, not
   * an expression. The callback is of the form
   * <tt>moduleHandler.handle(newModule)</tt>.
   */
  function setNewModuleHandler(newModuleHandler) {
    myNewModuleHandler = newModuleHandler;
  }

  /**
   * A new-module-handler which returns the new module without
   * instantiating it.
   */
  var obtainNewModule = freeze({
    handle: simpleFrozenFunc(function(newModule){ return newModule; })
  });

  /**
   * Makes and returns a fresh "normal" module handler whose imports
   * are initialized to a copy of the sharedImports.
   * <p>
   * This handles a new module by calling it, passing it the imports
   * object held in this handler. Successive modules handled by the
   * same "normal" handler thereby see a simulation of successive
   * updates to a shared global scope.
   */
  function makeNormalNewModuleHandler() {
    var imports = copy(sharedImports);
    var lastOutcome = void 0;
    return freeze({
      getImports: simpleFrozenFunc(function() { return imports; }),
      setImports: simpleFrozenFunc(function(newImports) { 
        imports = newImports; 
      }),
      getLastOutcome: simpleFrozenFunc(function() { 
        return lastOutcome; 
      }),
      getLastValue: simpleFrozenFunc(function() {
        if (lastOutcome && lastOutcome[0]) {
          return lastOutcome[1];
        } else {
          return void 0;
        }
      }),
      handle: simpleFrozenFunc(function(newModule) {
        try {
          var result = newModule(___, imports);
          lastOutcome = [true, result];
          return result;
        } catch (ex) {
          // TODO(erights): I hope that this outcome reporting can be
          // adequate to replace the in-place rewrite currently being
          // done by HtmlCompiler.java as explained below.
          lastOutcome = [false, ex];
          throw ex;
        }
      }),
      /**
       * This emulates HTML5 exception handling for scripts as discussed at
       * http://code.google.com/p/google-caja/wiki/UncaughtExceptionHandling
       * and see HtmlCompiler.java for the code that calls this.
       * @param exception a raw exception.  Since {@code throw} can raise any
       *   value, exception could be any value accessible to cajoled code, or
       *   any value thrown by an API imported by cajoled code.
       * @param onerror the value of the raw reference "onerror" in top level
       *   cajoled code.  This will likely be undefined much of the time, but
       *   could be anything.  If it is a simpleFunc, it can be called with
       *   three strings (message, source, lineNum) as the
       *   {@code window.onerror} event handler.
       * @param {string} source a URI describing the source file from which the
       *   error originated.
       * @param {string} lineNum the approximate line number in source at which
       *   the error originated.
       */
      handleUncaughtException: function (exception, onerror, source, lineNum) {

        // Cause exception to be rethrown if it is uncatchable.
        ___.tameException(exception);

        var message = 'unknown';
        if ('object' === typeof exception && exception !== null) {
          message = String(exception.message || exception.desc || message);
        }

        // If we wanted to provide a hook for containers to get uncaught
        // exceptions, it would go here before onerror is invoked.

        // See the HTML5 discussion for the reasons behind this rule.
        var shouldReport = (
            isSimpleFunc(onerror)
            ? ___.simpleFunc(onerror)(message, String(source), String(lineNum))
            : onerror !== null);
        if (shouldReport !== false) {
          caja.log(source + ':' + lineNum + ': ' + message);
        }
      }
    });
  }

  /**
   * A module is a plugin-maker function.
   * <p>
   * loadModule(module) marks module as a simpleFunc, freezes it,
   * asks the current new-module-handler to handle it (thereby
   * notifying the handler), and returns the new module.
   */
  function loadModule(module) {
    return callPub(myNewModuleHandler, 'handle', [simpleFrozenFunc(module)]);
  }

  var registeredImports = [];

  /**
   * Gets or assigns the id associated with this (assumed to be)
   * imports object, registering it so that
   * <tt>getImports(getId(imports)) === imports</tt>.
   * <p>
   * This system of registration and identification allows us to
   * cajole html such as
   * <pre>&lt;a onmouseover="alert(1)"&gt;Mouse here&lt;/a&gt;</pre>
   * into html-writing JavaScript such as<pre>
   * ___IMPORTS___.document.innerHTML = "
   *  &lt;a onmouseover=\"
   *    (function(___IMPORTS___) {
   *      ___IMPORTS___.alert(1);
   *    })(___.getImports(" + ___.getId(___IMPORTS___) + "))
   *  \"&gt;Mouse here&lt;/a&gt;
   * ";
   * </pre>
   * If this is executed by a plugin whose imports is assigned id 42,
   * it generates html with the same meaning as<pre>
   * &lt;a onmouseover="___.getImports(42).alert(1)"&gt;Mouse here&lt;/a&gt;
   * </pre>
   * <p>
   * An imports is not registered and no id is assigned to it until the
   * first call to <tt>getId</tt>. This way, an imports that is never
   * registered, or that has been <tt>unregister</tt>ed since the last
   * time it was registered, will still be garbage collectable.
   */
  function getId(imports) {
    enforceType(imports, 'object', 'imports');
    var id;
    if ('id___' in imports) {
      id = enforceType(imports.id___, 'number', 'id');
    } else {
      id = imports.id___ = registeredImports.length;
    }
    registeredImports[id] = imports;
    return id;
  }

  /**
   * Gets the imports object registered under this id.
   * <p>
   * If it has been <tt>unregistered</tt> since the last
   * <tt>getId</tt> on it, then <tt>getImports</tt> will fail.
   */
  function getImports(id) {
    var result = registeredImports[enforceType(id, 'number', 'id')];
    if (result === (void 0)) {
      fail('imports#', id, ' unregistered');
    }
    return result;
  }

  /**
   * If you know that this <tt>imports</tt> no longers needs to be
   * accessed by <tt>getImports</tt>, then you should
   * <tt>unregister</tt> it so it can be garbage collected.
   * <p>
   * After unregister()ing, the id is not reassigned, and the imports
   * remembers its id. If asked for another <tt>getId</tt>, it
   * reregisters itself at its old id.
   */
  function unregister(imports) {
    enforceType(imports, 'object', 'imports');
    if ('id___' in imports) {
      var id = enforceType(imports.id___, 'number', 'id');
      registeredImports[id] = (void 0);
    }
  }


  ////////////////////////////////////////////////////////////////////////
  // Trademarking
  ////////////////////////////////////////////////////////////////////////

  // Any object may be used as a trademark.

  /**
   * Returns true if the object has a list of trademarks
   * and the given trademark is in the list.
   */
  function hasTrademark(trademark, obj) {
    if (!hasOwnProp(obj, 'trademarks___')) { return false; }
    var list = obj.trademarks___;
    for (var i=0; i < list.length; ++i) {
      if (list[i]===trademark) { return true; }
    }
    return false;
  }

  /**
   * Throws an exception if the object does not have any trademarks or
   * the given trademark is not in the list of trademarks.
   */
  function guard(trademark, obj) {
    enforce (hasTrademark(trademark, obj),
        'This object does not have the given trademark' );
  }

  /**
   * This function adds the given trademark to the given object's list of
   * trademarks.
   * If the trademark list doesn't exist yet, this function creates it.
   * JSON containers and functions may be stamped at any time; constructed
   * objects may only be stamped during construction unless the third
   * parameter is truthy.
   */
  function stamp(trademark, obj, opt_allow_constructed) {
    enforce (typeof trademark === 'object',
        'The supplied trademark is not an object.');
    enforce (!isFrozen(obj), 'The supplied object ' + obj + ' is frozen.');
    if (!isJSONContainer(obj) &&
        (typeof obj !== 'function') &&
        !obj.underConstruction___ &&
        !opt_allow_constructed) {
      fail('The supplied object ', obj,
           ' has already been constructed and may not be stamped.');
    }
    var list = obj.underConstruction___ ?
        'delayedTrademarks___' : 'trademarks___';
    if (!obj[list]) { obj[list] = []; }
    obj[list].push(trademark);
    return obj;
  }

  function initializeMap(list) {
    var result = {};
    for (var i = 0; i < list.length; i+=2) {
      setPub(result, list[i], list[i+1]);
    }
    return result;
  }

  ////////////////////////////////////////////////////////////////////////
  // Sealing and Unsealing
  ////////////////////////////////////////////////////////////////////////
  /**
   * Returns a pair of functions such that the seal(x) wraps x in an object
   * so that only unseal can get x back from the object.
   *
   * @return {object} of the form
   *     { seal: function (x) { return {}; },
   *       unseal: function (obj) { return x; } }.
   */
  function makeSealerUnsealerPair() {
    var flag = false;  // Was a box successfully unsealed
    var squirrel = null;  // Receives the payload from an unsealed box.
    function seal(payload) {
      function box() {
        flag = true, squirrel = payload;
      }
      box.toString = simpleFrozenFunc(function () { return '(box)'; });
      return simpleFrozenFunc(box);
    }
    function unseal(box) {
      // Start off in a known good state.
      flag = false;
      squirrel = null;
      try {  // Don't do anything outside try to foil forwarding functions.
        asSimpleFunc(box)();
        if (!flag) { throw new Error('Sealer/Unsealer mismatch'); }
        return squirrel;
      } finally {
        // Restore to a known good state.
        flag = false;
        squirrel = null;
      }
    }
    return freeze({ seal: seal, unseal: unseal });
  }

  ////////////////////////////////////////////////////////////////////////
  // Needed for Valija
  // TODO(erights): nothing in this section is tested yet
  ////////////////////////////////////////////////////////////////////////

  /**
   * <tt>___.construct(ctor, [args...])</tt> is equivalent to <tt>new
   * asCtor(ctor)(args...)</tt>. 
   * <p>
   * TODO(erights): Cajole to tt>construct()</tt> instead of
   * <tt>asCtor()</tt>. Remember to make the corresponding change to
   * caja-debugmode.js.
   * <p>
   * BUG TODO(erights): To cope correctly with Date, we need to move
   * the logic from caja-debugmode.js to here.
   */
  function construct(ctor, args) {
    ctor = asCtor(ctor);
    if (ctor.make___) {
      return new ctor.make___(args);
    }
    var result = primBeget(ctor.prototype);
    var altResult = ctor.apply(result, args);
    switch (typeof altResult) {
      case 'object': {
        if (null !== altResult) { return altResult; }
      }
      case 'function': {
        return altResult;
      }
    }
    return result;
  }

  var magicCount = 0;

  /**
   * Creates a new mutable associative table mapping from the <tt>===</tt> 
   * identity of arbitrary keys to arbitrary values (with the caveat
   * that NaN is a valid key even though it isn't <tt>===</tt> to itself).
   * <p>
   * JavaScript has no such construct, and I had thought it impossible
   * to implement both correctly and with the right complexity measure
   * using the standard elements of JavaScript. However, the following
   * <ul>
   * <li>should work across frames, 
   * <li>should have the right garbage collection behavior, 
   * <li>should have O(1) complexity measure within a frame where
   *     collision is impossible, 
   * <li>and should have O(1) complexity measure between frames with
   *     high probability. 
   * </ul>
   * Is this technique well known?
   */
  function newTable() {
    magicCount++;
    var myMagicIndexName = '_' + Math.random() + '_' + 
                           magicCount + '_index___';
    var myKeys = [];
    var myValues = [];

    function set(key, value) {
      switch (typeof key) {
        case 'object':
        case 'function': {
          if (null === key) { myValues.prim_null = value; return; } 
          var index = myKeys.length;
          key[myMagicIndexName] = index;
          myKeys[index] = key;
          myValues[index] = value;
          return;
        }
        case 'string': { myValues['str_' + key] = value; return; }
        default: { myValues['prim_' + key] = value; return; }
      }
    }

    /** 
     * If the key is absent, returns <tt>undefined</tt>.
     * <p>
     * Users of this table cannot distinguish an <tt>undefined</tt>
     * value from an absent key.
     */
    function get(key) {
      var index;
      switch (typeof key) {
        case 'object':
        case 'function': {
          if (null === key) { return myValues.prim_null; } 
          var index = key[myMagicIndexName];
          if ((void 0) === index) { return (void 0); }
          if (myKeys[index] !== key) {
            // In case of collision
            for (index = 0; index < myKeys.length; index++) {
              if (myKeys[index] === key) { break; }
            }
            if (index === myKeys.length) { return (void 0); }
            // predictive MRU cache
            key[myMagicIndexName] = index;
          }
          return myValues[index];
        }
        case 'string': { return myValues['str_' + key];   }
        default: { return myValues['prim_' + key]; }
      }
    }

    return primFreeze({
      get: simpleFrozenFunc(get),
      set: simpleFrozenFunc(set)
    });
  }


  /**
   * Is <tt>allegedParent</tt> on <obj>'s prototype chain?
   * <p>
   * Although in raw JavaScript <tt>'foo' instanceof String</tt> is
   * false, to reduce the differences between primitives and their
   * wrappers, <tt>inheritsFrom('foo', String.prototype)</tt> is true.
   */
  function inheritsFrom(obj, allegedParent) {
    if (null === obj) { return false; }
    if (void 0 === obj) { return false; }
    if (typeof obj === 'function') { return false; }
    if (typeof allegedParent !== 'object') { return false; }
    if (null === allegedParent) { return false; }
    function F() {}
    F.prototype = allegedParent;
    return Object(obj) instanceof F;
  }

  /**
   * 
   */
  function getSuperCtor(func) {
    enforceType(func, 'function');
    if (isCtor(func) || isSimpleFunc(func)) {
      var result = directConstructor(func.prototype);
      if (isCtor(result) || isSimpleFunc(result)) {
        return result;
      }
    }
    return (void 0);
  }

  // TODO(erights): When we retire original Caja and stop protecting
  // properties ending in a single underscore, remove the "[^_]" below.
  var Attribute = new RegExp(
    '^(.*[^_])_(?:canRead|canCall|getter|handler)___$');

  /**
   * Returns a list of all canReadPub properties, whether or not
   * they are canEnumPub. 
   */
  function getOwnPropertyNames(obj) {
    var result = [];
    var seen = {};
    for (var k in obj) {
      var match = Attribute.exec(k);
      if (match !== null) {
        var base = match[1];
        if (!hasOwnProp(seen, base)) {
          seen[base] = true;
          result.push(base);
        }
      }
    }
    return result;
  }
  
  function getMethodNames(func) {
    enforceType(func, 'function');
    var result = [];
    var protoNames = getOwnPropertyNames(func.prototype);
    for (var i = 0; i < protoNames.length; i++) {
      var k = protoNames[i];
      var v = func.prototype[k];
      if (typeof v === 'function') {
        result.push(k);
      }
    }
    return result;
  }

  /**
   * Like primBeget(), but applicable only to records.
   */
  function beget(parent) {
    if (!isRecord(parent)) {
      fail('Can only beget() records: ', parent);
    }
    return primBeget(parent);
  }

  
  ////////////////////////////////////////////////////////////////////////
  // Exports
  ////////////////////////////////////////////////////////////////////////
  safeCaja = {
    // Diagnostics and condition enforcement
    log: log,
    fail: fail,
    enforce: enforce,
    enforceType: enforceType,
    enforceNat: enforceNat,

    // walking prototype chain, checking JSON containers
    directConstructor: directConstructor,
    getFuncCategory: getFuncCategory,
    isDirectInstanceOf: isDirectInstanceOf,
    isInstanceOf: isInstanceOf,
    isRecord: isRecord,           isArray: isArray,
    isJSONContainer: isJSONContainer,
    freeze: freeze,
    copy: copy,                   snapshot: snapshot,

    // Accessing properties
    canReadPub: canReadPub,       readPub: readPub,
    canEnumPub: canEnumPub,
    canEnumOwn: canEnumOwn,
    canInnocentEnum: canInnocentEnum,
    BREAK: BREAK,                 each: each,
    canCallPub: canCallPub,       callPub: callPub,
    canSetPub: canSetPub,         setPub: setPub,
    canDeletePub: canDeletePub,   deletePub: deletePub,

    // Trademarking
    hasTrademark: hasTrademark,
    guard: guard,

    // Sealing & Unsealing
    makeSealerUnsealerPair: makeSealerUnsealerPair,

    // Other
    def: def,
    USELESS: USELESS,
    manifest: manifest,

    // Needed for Valija
    construct: construct,
    newTable: newTable,
    inheritsFrom: inheritsFrom,
    getSuperCtor: getSuperCtor,
    getOwnPropertyNames: getOwnPropertyNames,
    getMethodNames: getMethodNames,
    beget: beget
  };

  each(safeCaja, simpleFrozenFunc(function(k, v) {
    switch (typeof v) {
      case 'object': {
        if (v !== null) { primFreeze(v); }
        break;
      }
      case 'function': {
        simpleFrozenFunc(v);
        break;
      }
    }
  }));

  caja = copy(safeCaja);
  caja.def = unsafeDef;

  sharedImports = {
    caja: safeCaja,

    'null': null,
    'false': false,
    'true': true,
    'NaN': NaN,
    'Infinity': Infinity,
    'undefined': (void 0),
    parseInt: simpleFrozenFunc(parseInt),
    parseFloat: simpleFrozenFunc(parseFloat),
    isNaN: simpleFrozenFunc(isNaN),
    isFinite: simpleFrozenFunc(isFinite),
    decodeURI: simpleFrozenFunc(decodeURI),
    decodeURIComponent: simpleFrozenFunc(decodeURIComponent),
    encodeURI: simpleFrozenFunc(encodeURI),
    encodeURIComponent: simpleFrozenFunc(encodeURIComponent),
    Math: Math,

    Object: Object,
    Array: Array,
    String: String,
    Boolean: Boolean,
    Number: Number,
    Date: Date,
    RegExp: RegExp,

    Error: Error,
    EvalError: EvalError,
    RangeError: RangeError,
    ReferenceError: ReferenceError,
    SyntaxError: SyntaxError,
    TypeError: TypeError,
    URIError: URIError
  };

  each(sharedImports, simpleFrozenFunc(function(k, v) {
    switch (typeof v) {
      case 'object': {
        if (v !== null) { primFreeze(v); }
        break;
      }
      case 'function': {
        primFreeze(v);
        break;
      }
    }
  }));
  primFreeze(sharedImports);

  ___ = {
    // Diagnostics and condition enforcement
    getLogFunc: getLogFunc,
    setLogFunc: setLogFunc,

    isFrozen: isFrozen,
    primFreeze: primFreeze,

    // Accessing property attributes.
    canRead: canRead,        grantRead: grantRead,
    canEnum: canEnum,        grantEnumOnly: grantEnumOnly,
    canCall: canCall,        grantCall: grantCall,
    canSet: canSet,          grantSet: grantSet,
    canDelete: canDelete,    grantDelete: grantDelete,

    // Module linkage
    readImport: readImport,

    // Classifying functions
    isCtor: isCtor,
    isMethod: isMethod,
    isSimpleFunc: isSimpleFunc,
    isXo4aFunc: isXo4aFunc,
    ctor: ctor,                   asCtorOnly: asCtorOnly,
    asCtor: asCtor,
    splitCtor: splitCtor,
    method: method,
    simpleFunc: simpleFunc,       asSimpleFunc: asSimpleFunc,
    simpleFrozenFunc: simpleFrozenFunc,
    xo4a: xo4a,
    setMember: setMember,
    setMemberMap: setMemberMap,
    initializeMap: initializeMap,
    attach: attach,

    // Accessing properties
    canReadProp: canReadProp,     readProp: readProp,
    inPub: inPub,
    canEnumProp: canEnumProp,
    canCallProp: canCallProp,     callProp: callProp,
    canSetProp: canSetProp,       setProp: setProp,
    canSetStatic: canSetStatic,   setStatic: setStatic,
    canDeleteProp: canDeleteProp, deleteProp: deleteProp,

    // Other
    hasOwnProp: hasOwnProp,
    same: same,
    args: args,
    tameException: tameException,
    primBeget: primBeget,
    callStackUnsealer: callStackSealer.unseal,
    RegExp: RegExp,  // Available to rewrite rule w/o risk of masking
    stamp: stamp,
    asFirstClass: asFirstClass,

    // Taming mechanism
    useGetHandler: useGetHandler,
    useApplyHandler: useApplyHandler,
    useCallHandler: useCallHandler,
    useSetHandler: useSetHandler,
    useDeleteHandler: useDeleteHandler,

    grantSimpleFunc: grantSimpleFunc,
    grantGeneric: grantGeneric,
    handleGeneric: handleGeneric,
    grantTypedGeneric: grantTypedGeneric,
    grantMutator: grantMutator,
    grantMethod: grantMethod,

    enforceMatchable: enforceMatchable,
    all2: all2,

    // Taming decisions
    sharedImports: sharedImports,

    // Module loading
    getNewModuleHandler: getNewModuleHandler,
    setNewModuleHandler: setNewModuleHandler,
    obtainNewModule: obtainNewModule,
    makeNormalNewModuleHandler: makeNormalNewModuleHandler,
    loadModule: loadModule,

    getId: getId,
    getImports: getImports,
    unregister: unregister
  };

  each(caja, simpleFrozenFunc(function(k, v) {
    if (k in ___) {
      fail('internal: initialization conflict: ', k);
    }
    if (typeof v === 'function') {
      simpleFrozenFunc(v);
      grantCall(caja, k);
    }
    ___[k] = v;
  }));
  setNewModuleHandler(makeNormalNewModuleHandler());
})(this);
