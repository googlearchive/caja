// Copyright (C) 2007 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview the Caja runtime library.
 * It is written in Javascript, not Caja, and would be rejected by the Caja
 * translator. This module exports two globals:<ol>
 * <li>"___" for use by the output of the Caja translator and by some
 *     other untranslated Javascript code.
 * <li>"caja" providing some common services to the Caja programmer.
 * </ol>
 * @author erights@gmail.com
 */

// TODO(erights): All code text in comments should be enclosed in
// {@code ...}.


////////////////////////////////////////////////////////////////////////
// Caja adds the following common Javascript extensions to ES3
// TODO(erights): Move such extensions to a separate extensions.js,
//                and change the conflict rule (for now) to fail on
//                detecting a conflict.
////////////////////////////////////////////////////////////////////////

// Add a tag to builtin types so we can check the class cross-frame.
Array.typeTag___ = 'Array';
Object.typeTag___ = 'Object';

if (Array.prototype.indexOf === (void 0)) {
  /**
   * Returns the first index at which the specimen is found (by
   * "===") or -1 if none.
   */
  Array.prototype.indexOf = function(specimen) {
    var len = this.length;
    for (var i = 0; i < len; i += 1) {
      if (this[i] === specimen) {
        return i;
      }
    }
    return -1;
  };
}

if (Array.prototype.lastIndexOf === (void 0)) {
  /**
   * Returns the last index at which the specimen is found (by
   * "===") or -1 if none.
   */
  Array.prototype.lastIndexOf = function(specimen) {
    for (var i = this.length; --i >= 0; ) {
      if (this[i] === specimen) {
        return i;
      }
    }
    return -1;
  };
}

if (Date.prototype.toISOString === (void 0)) {
  /**
   * Like the date.toJSONString() method defined in json.js, but
   * without the surrounding quotes.
   */
  Date.prototype.toISOString = function() {
    function f(n) {
      return n < 10 ? '0' + n : n;
    }
    return (this.getUTCFullYear()     + '-' +
            f(this.getUTCMonth() + 1) + '-' +
            f(this.getUTCDate())      + 'T' +
            f(this.getUTCHours())     + ':' +
            f(this.getUTCMinutes())   + ':' +
            f(this.getUTCSeconds())   + 'Z');
  };
}

/**
 * Bind this function object to <tt>thisObject</tt>, which will serve as the
 * value of <tt>this</tt> during invocation. Curry on a partial set of arguments
 * in <tt>var_args</tt>. Return the curried result as a new function object.
 */
Function.prototype.bind = function(thisObject, var_args) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  return ___.primFreeze(___.simpleFunc(function(var_args) {
    self.apply(thisObject, args.concat(___.args(arguments)));
  }));
};

Function.prototype['super'] = function() {
  caja.fail('"super" may only be called at the beginning of a Caja constructor.');
};

// caja.js exports the following names to the Javascript global
// namespace. Caja code can only use the "caja" object. The "___"
// object is for use by code generated by the Caja translator, and by
// Javascript code (such as a powerbox) in the embedding application.

// Caja virtually adds Object.prototype.freeze_(), so that a
// constructed object can freeze itself, but its clients cannot freeze
// it. However, in order not to disrupt innocent code (see
// canInnocentEnum() below), the only property names Caja may add to
// primordial objects are names ending in triple underbar. Therefore,
// Caja instead adds Object.prototype.freeze__handler___().

var caja;
var ___;

// Explicitly passing in the actual global object to avoid
// ReferenceErrors when referring to potentially nonexistent objects
// like HTMLDivElement.

(function(global) {
  
  ////////////////////////////////////////////////////////////////////////
  // Diagnostics and condition enforcement
  ////////////////////////////////////////////////////////////////////////
  
  /**
   * The initial default logging function does nothing. 
   * <p>
   * Note: JavaScript has no macros, so even in the "does nothing"
   * case, remember that the arguments are still evaluated. 
   */
  var myLogFunc_ = function(str, opt_stop) {};

  /**
   * Gets the currently registered logging function.
   */
  function getLogFunc() { return myLogFunc_; }

  /**
   * Register newLogFunc as the current logging function, to be called
   * by <tt>___.log(str)</tt> and <tt>___.fail(...)</tt>. 
   * <p>
   * A logging function is assumed to have the signature 
   * <tt>(str, opt_stop)</tt>, where<ul>
   * <li><tt>str</tt> is the diagnostic string to be logged, and
   * <li><tt>opt_stop</tt>, if present and <tt>true</tt>, indicates
   *     that normal flow control is about to be terminated by a
   *     throw. This provides the logging function the opportunity to
   *     terminate normal control flow in its own way, such as by
   *     invoking an undefined method, in order to trigger a Firebug
   *     stacktrace. 
   * </ul>
   */
  function setLogFunc(newLogFunc) { myLogFunc_ = newLogFunc; }

  /**
   * Calls the currently registered logging function.
   */
  function log(str) { myLogFunc_(String(str)); }


  /** 
   * Throw, and optionally log, an error whose message is the
   * concatentation of the arguments.
   * <p>
   * The arguments are converted to strings (presumably by an
   * implicit call to ".toString()") and appended together to make
   * the message of the Error that's thrown.
   */
  function fail(var_args) {
    (typeof console !== 'undefined') && console.trace();
    var message = Array.prototype.slice.call(arguments, 0).join('');
    myLogFunc_(message, true);
    throw new Error(message);
  }
  
  /** 
   * Like an assert that can't be turned off.
   * <p>
   * Either returns true (on success) or throws (on failure). The
   * arguments starting with <tt>var_args</tt> are converted to
   * strings and appended together to make the message of the Error
   * that's thrown.
   * <p>
   * TODO(erights) We may deprecate this in favor of <pre>
   *     test || fail(var_args...)
   * </pre> or <pre>
   *     if (!test) { fail(var_args...); }
   * </pre>
   */
  function enforce(test, var_args) {
    return test || fail.apply({}, Array.prototype.slice.call(arguments, 1));
  }
  
  /**
   * Enforces <tt>typeof specimen === typename</tt>, in which case
   * specimen is returned.
   * <p>
   * If not, throws an informative TypeError
   * <p>
   * opt_name, if provided, should be a name or description of the
   * specimen used only to generate friendlier error messages.
   */
  function enforceType(specimen, typename, opt_name) {
    if (typeof specimen !== typename) {
      fail('expected ', typename, ' instead of ', typeof specimen,
           ': ', (opt_name || specimen));
    }
    return specimen;
  }
  
  /**
   * Enforces that specimen is a non-negative integer within the range
   * of exactly representable consecutive integers, in which case
   * specimen is returned.
   * <p>
   * "Nat" is short for "Natural number".
   */
  function enforceNat(specimen) {
    enforceType(specimen, 'number');
    if (Math.floor(specimen) !== specimen) {
      fail('Must be integral: ', specimen);
    }
    if (specimen < 0) {
      fail('Must not be negative: ', specimen);
    }
    // Could pre-compute precision limit, but probably not faster
    // enough to be worth it.
    if (Math.floor(specimen-1) !== specimen-1) {
      fail('Beyond precision limit: ', specimen);
    }
    if (Math.floor(specimen-1) >= specimen) {
      fail('Must not be infinite: ', specimen);
    }
    return specimen;
  }

  ////////////////////////////////////////////////////////////////////////
  // Privileged fault handlers
  ////////////////////////////////////////////////////////////////////////

  function debugReference(obj) {
    switch (typeof obj) {
      case 'object':
        if (obj === null) { return '<null>'; }
        return '[' + (obj.constructor.name || 'Object') + ']';
      default:
        return '(' + obj + ':' + (typeof obj) + ')';
    }
  }

  /**
   *
   */
  var myKeeper_ = {

    /**
     *
     */
    toString: function() { return '<Logging Keeper>'; },

    /**
     *
     */
    handleRead: function(obj, name, opt_shouldThrow) {
      if (opt_shouldThrow) {
        fail('Not readable: (', debugReference(obj), ').', name);
      }
      log('Not readable: (' + debugReference(obj) + ').' + name);
      return (void 0);
    },

    /**
     *
     */
    handleCall: function(obj, name, args) {
      fail('Not callable: (', debugReference(obj), ').', name);
    },

    /**
     * 
     */
    handleSet: function(obj, name, val) {
      fail('Not settable: (', debugReference(obj), ').', name);
    },

    /**
     * 
     */
    handleDelete: function(obj, name) {
      fail('Not deletable: (', debugReference(obj), ').', name);
    }
  };

  /**
   * 
   */
  function getKeeper() { return myKeeper_; }

  /**
   * 
   */
  function setKeeper(newKeeper) { myKeeper_ = newKeeper; }

  /**
   * 
   */
  Object.prototype.handleRead___ = function(name, opt_shouldThrow) {
    var handlerName = name + '_getter___';
    if (this[handlerName]) {
      return this[handlerName](opt_shouldThrow);
    }
    return myKeeper_.handleRead(this, name, opt_shouldThrow);
  };

  /**
   * 
   */
  Object.prototype.handleCall___ = function(name, args) {
    var handlerName = name + '_handler___';
    if (this[handlerName]) {
      return this[handlerName].call(this, args);
    }
    return myKeeper_.handleCall(this, name, args);
  };

  /**
   * 
   */
  Object.prototype.handleSet___ = function(name, val) {
    var handlerName = name + '_setter___';
    if (this[handlerName]) {
      return this[handlerName](val);
    }
    return myKeeper_.handleSet(this, name, val);
  };

  /**
   * 
   */
  Object.prototype.handleDelete___ = function(name) {
    var handlerName = name + '_deleter___';
    if (this[handlerName]) {
      return this[handlerName]();
    }
    return myKeeper_.handleDelete(this, name);
  };
  
  ////////////////////////////////////////////////////////////////////////
  // Overriding some very basic primordial methods
  ////////////////////////////////////////////////////////////////////////
  
  /**
   * Returns true only if we can call
   * Object.prototype.hasOwnProperty on this object without
   * exploding. 
   * <p>
   * On Firefox, it seems that calling hasOwnProperty on an
   * HTMLDivElement sometimes causes an
   * "Illegal operation on WrappedNative prototype object".
   * <p>
   * SECURITY BUG STOPGAP TODO(erights)
   */
  var canCallHasOwnProperty = function(obj) { return true; };
  
  // When we're in a non-browser environment, such that there isn't
  // a global HTMLDivElement, then we don't need to worry about
  // this bug.
  if (typeof global.HTMLDivElement === 'function') {
    canCallHasOwnProperty = function(obj) {
      return !(obj instanceof global.HTMLDivElement);
    };
  }
  
  var originalHOP_ = Object.prototype.hasOwnProperty;
  
  /**
   * <tt>hasOwnProp(obj.prop)</tt> means what
   * <tt>obj.hasOwnProperty(prop)</tt> would normally mean in an
   * unmodified Javascript system.
   */
  function hasOwnProp(obj, name) { 
    var t = typeof obj;
    if (t !== 'object' && t !== 'function') { 
      return false; 
    }
    if (canCallHasOwnProperty(obj)) {
      // Fails in Firefox for some DOM objects intermittently(?!) 
      // with "Illegal operation on WrappedNative prototype object".
      // For these, canCallHasOwnProperty must say false.
      return originalHOP_.call(obj, name); 
    } else {
      return false;
    }
  }
  
  ////////////////////////////////////////////////////////////////////////
  // walking prototype chain, checking JSON containers
  ////////////////////////////////////////////////////////////////////////
  
  /**
   * Does str end with suffix? 
   */
  function endsWith(str, suffix) {
    enforceType(str, 'string');
    enforceType(suffix, 'string');
    var strLen = str.length;
    var sufLen = suffix.length;
    return strLen >= sufLen && 
      (str.substring(strLen-sufLen, strLen) === suffix);
  }

  /**
   * Returns the 'constructor' property of obj's prototype.
   * <p>
   * By "obj's prototype", we mean the object that obj directly
   * inherits from, not the value of its 'prototype' property. If
   * obj has a '__proto__' property, then we assume we're on a
   * platform (like Firefox) in which this reliably gives us obj's
   * prototype. Otherwise, we memoize the apparent prototype into
   * '__proto__' to speed up future queries.
   * <p>
   * If obj is a function or not an object, return undefined.
   */
  function directConstructor(obj) {
    if (obj === null) { return (void 0); }
    try {
      if (typeof obj !== 'object') {
        // Note that functions thereby return undefined,
        // so directConstructor() doesn't provide access to the
        // forbidden Function constructor.
        return (void 0);
      }
      // The following test will initially return false in IE
      if (hasOwnProp(obj, '__proto__')) {
        if (obj.__proto__ === null) { return (void 0); }
        return obj.__proto__.constructor;
      }
      var result;
      if (!hasOwnProp(obj, 'constructor')) {
        result = obj.constructor;
      } else {
        var oldConstr = obj.constructor;
        if (!(delete obj.constructor)) { return (void 0); }
        result = obj.constructor;
        obj.constructor = oldConstr;
      }
      if (result.prototype.constructor === result) {
        // Memoize, so it'll be faster next time.
        obj.__proto__ = result.prototype;
      }
      return result;
    } catch (ex) {
      return (void 0);
    }
  }

  /**
   * A JSON container is an object whose direct constructor is
   * Object or Array.
   * <p>
   * These are the kinds of non-primitive objects that can be
   * expressed in the JSON language.
   */
  function isJSONContainer(obj) {
    if (obj == null) { return false; }  // Match null and undefined
    var constr = directConstructor(obj);
    var typeTag = constr && constr.typeTag___;
    return typeTag === 'Object' || typeTag === 'Array';
  }
  
  /**
   * If obj is frozen, Caja code cannot directly assign to
   * properties of obj, nor directly add or delete properties to
   * obj.
   * <p>
   * The status of being frozen is not inherited. If A inherits from
   * B (i.e., if A's prototype is B), then (we hope) B must be
   * frozen regardless, but A may or may not be frozen.
   * <p>
   * If typeof <tt>obj</tt> is neither 'object' nor 'function', then
   * it's currently considered frozen.
   */
  function isFrozen(obj) { 
    var t = typeof obj;
    if (t !== 'object' && t !== 'function') { 
      return true; 
    }
    return hasOwnProp(obj, '___FROZEN___'); 
  }
  
  /**
   * Mark obj as frozen so that Caja code cannot directly assign to its
   * properties.
   * <p>
   * If obj is a function, also freeze obj.prototype.
   * <p>
   * This appears as <tt>___.primFreeze(obj)</tt> and is wrapped by
   * the virtual <tt>Object.prototype.freeze_()</tt>.
   */
  function primFreeze(obj) {
    // Fail silently on undefined, since
    //   (function(){
    //     var f = Foo;
    //     if (true) { function Foo() {} }
    //   })();
    // gets translated to (roughly)
    //   (function(){
    //     var Foo;
    //     var f = ___.primFreeze(Foo);
    //     if (true) { Foo = function Foo() {}; }
    //   })();
    if ((void 0) === obj) { return obj; }
    if (null === obj) { return obj; }
    if (isFrozen(obj)) { return obj; }
    var typ = typeof obj;
    if (typ !== 'object' && typ !== 'function') { return obj; }

    // badFlags are names of properties we need to turn off.
    // We accumulate these first, so that we're not in the midst of a
    // for/in loop on obj while we're deleting properties from obj.
    var badFlags = [];
    for (var k in obj) {
      if (endsWith(k, '_canSet___') || endsWith(k, '_canDelete___')) {
        if (obj[k]) {
          badFlags.push(k);
        }
      }
    }
    for (var i = 0; i < badFlags.length; i++) {
      var flag = badFlags[i];
      if (hasOwnProp(obj, flag)) {
        if (!(delete obj[flag])) {
          fail('internal: failed delete: ', debugReference(obj), '.', flag);
        }
      }
      if (obj[flag]) {
        // At the time of this writing, this case
        // should never be able to happen, since
        // prototypes are always frozen before use,
        // and frozen objects cannot have these flags
        // set on them. We code it this way to allow
        // for a future optimization, where the
        // prototype can record as canSet those
        // properties that appear in instances that
        // inherit from this prototype.
        obj[flag] = false;
      }
    }
    obj.___FROZEN___ = true;
    if (typ === 'function') {
      // Do last to avoid possible infinite recursion.
      if (obj.prototype) { primFreeze(obj.prototype); }
    }
    return obj;
  }

  /**
   * Like primFreeze(obj), but applicable only to JSON containers.
   */
  function freeze(obj) {
    if (!isJSONContainer(obj)) {
      fail('caja.freeze(obj) applies only to JSON Containers: ',
           debugReference(obj));
    }
    return primFreeze(obj);
  }
  
  /**
   * Makes a mutable copy of a JSON container.
   * <p>
   * Even if the original is frozen, the copy will still be mutable.
   */
  function copy(obj) {
    if (!isJSONContainer(obj)) {
      fail('caja.copy(obj) applies only to JSON Containers: ',
           debugReference(obj));
    }
    var result = (obj.constructor.typeTag___ === 'Array') ? [] : {};
    each(obj, simpleFunc(function(k, v) {
      result[k] = v;
    }));
    return result;
  }
  
  /**
   * A snapshot of a JSON container is a frozen copy of that
   * container. 
   */
  function snapshot(obj) {
    return primFreeze(copy(obj));
  }
  

  ////////////////////////////////////////////////////////////////////////
  // Accessing property attributes
  ////////////////////////////////////////////////////////////////////////
  
  /** Tests whether the fast-path canRead flag is set. */
  function canRead(obj, name)   { return !!obj[name + '_canRead___']; }
  /** Tests whether the fast-path canEnum flag is set. */
  function canEnum(obj, name)   { return !!obj[name + '_canEnum___']; }
  /**
   * Tests whether the fast-path canCall flag is set, or grantCall() has been
   * called.
   */
  function canCall(obj, name)   {
    return !!(obj[name + '_canCall___'] || obj[name + '_grantCall___']);
  }
  /**
   * Tests whether the fast-path canSet flag is set, or grantSet() has been
   * called.
   */
  function canSet(obj, name) {
    return !!(obj[name + '_canSet___'] || obj[name + '_grantSet___']);
  }
  /** Tests whether the fast-path canDelete flag is set. */
  function canDelete(obj, name) { return !!obj[name + '_canDelete___']; }
  
  /** 
   * Sets the fast-path canRead flag.
   * <p>
   * These are called internally to memoize decisions arrived at by
   * other means. 
   */
  function fastpathRead(obj, name) {
    enforce(obj != null, 'Cannot grant read of ', name, ' on null');
    obj[name + '_canRead___'] = true; 
  }
  
  /** allowEnum implies allowRead */
  function fastpathEnum(obj, name) {
    enforce(obj != null, 'Cannot grant enum of ', name, ' on null');
    fastpathRead(obj, name);
    obj[name + '_canEnum___'] = true;
  }
  
  /** allowEnum for members */
  function fastpathEnumOnly(obj, name) { 
    obj[name + '_canEnum___'] = true;
  }
  
  /** 
   * Simple functions should callable and readable, but methods
   * should only be callable.
   */
  function fastpathCall(obj, name) {
    enforce(obj != null, 'Cannot grant call of ', name, ' on null');
    obj[name + '_canCall___'] = true; 
    if (obj[name + '_canSet___']) {
      obj[name + '_canSet___'] = false;
    }
    if (obj[name + '_grantSet___']) {
      obj[name + '_grantSet___'] = false;
    }
  }

  /**
   * allowSet implies allowEnum and allowRead. It also disables the ability
   * to call.
   */
  function fastpathSet(obj, name) {
    enforce(obj != null, 'Cannot allow set of member ', name, ' on null');
    if (isFrozen(obj)) {
      fail("Can't set .", name, ' on frozen (', debugReference(obj), ')');
    }
    fastpathEnum(obj, name);
    obj[name + '_canSet___'] = true;
    if (obj[name + '_canCall___']) {
      obj[name + '_canCall___'] = false;
    }
    if (obj[name + '_grantCall___']) {
      obj[name + '_grantCall___'] = false;
    }
  }
  
  /**
   * BUG TODO(erights): allowDelete is not yet specified or
   * implemented. 
   */
  function fastpathDelete(obj, name) {
    enforce(obj != null, 'Cannot allow delete of member ', name, ' on null');
    if (isFrozen(obj)) {
      fail("Can't delete .", name, ' on frozen (', debugReference(obj), ')');
    }
    obj[name + '_canDelete___'] = true;
  }
  
  /**
   * The various <tt>grant*</tt> functions are called externally by
   * Javascript code to express whitelisting taming decisions. 
   */
  function grantRead(obj, name) {
    fastpathRead(obj, name);
  }
  
  function grantEnum(obj, name) {
    fastpathEnum(obj, name);
  }
  
  function grantEnumOnly(obj, name) {
    fastpathEnumOnly(obj, name);
  }
  
  function grantCall(obj, name) {
//    fastpathCall(obj, name);
    obj[name + '_grantCall___'] = true;
  }
  
  function grantSet(obj, name) {
//    fastpathSet(obj, name);
    obj[name + '_grantSet___'] = true;
  }
  
  function grantDelete(obj, name) {
    fastpathDelete(obj, name);
  }
  
  ////////////////////////////////////////////////////////////////////////
  // Classifying functions
  ////////////////////////////////////////////////////////////////////////

  function isCtor(constr)    {
    return (typeof(constr) === 'function') ?
        !!constr.___CONSTRUCTOR___ :
        false; 
  }
  function isMethod(meth)    { 
    return (typeof meth === 'function') ? 
        !!meth.___METHOD___ : 
        false; 
  }
  function isSimpleFunc(fun) { 
    return (typeof fun === 'function') ?
        !!fun.___SIMPLE_FUNC___ :
        false; 
  }
  function isXo4aFunc(func) {
    return (typeof func === 'function') ?
        (!!func.___XO4A___ || isSimpleFunc(func)) :
        false;
  }

  /**
   * Mark <tt>constr</tt> as a constructor.
   * <p>
   * If <tt>opt_Sup</tt> is provided, set constr.super to a function which
   * calls the super constructor to do its part in initializing the object.
   * <p>
   * A function is tamed and classified by calling one of
   * <tt>ctor()</tt>, <tt>method()</tt>, or <tt>simpleFunc()</tt>. Each
   * of these checks that the function hasn't already been classified by
   * any of the others. A function which has not been so classified is an
   * <i>untamed function</i>.
   * <p>
   * <tt>opt_name</tt>, if provided, should be the name of the constructor
   * function. Currently, this is used only to generate friendlier
   * error messages.
   */
  function ctor(constr, opt_Sup, opt_name) {
    enforceType(constr, 'function', opt_name);
    if (isMethod(constr)) {
      fail("Methods can't be constructors: ", constr);
    }
    // TODO(erights): We shouldn't be able to mark simple functions
    // as constructors, but we should be able to use simple functions
    // in caja.def().
    /* if (isSimpleFunc(constr)) {
      fail("Simple functions can't be constructors:", constr);
    } */
    constr.___CONSTRUCTOR___ = true;
    if (opt_Sup) {
      opt_Sup = asCtor(opt_Sup);
      if (hasOwnProp(constr, 'super')) {
        fail("Can't inherit twice: ", constr, ',', opt_Sup);
      } else {
        if (isFrozen(constr)) {
          fail('Derived constructor already frozen: ', constr);
        }
        constr['super'] = function(thisObj, var_args) {
          opt_Sup.init___.apply(thisObj, Array.prototype.slice.call(arguments, 1));
        };
      }
    }
    if (opt_name) {
      constr.NAME___ = String(opt_name);
    }
    return constr;  // translator freezes constructor later
  }

  /**
   * Supports the split-translation for first-class constructors.
   * <p>
   * The split translation translates a constructor definition (which
   * must not appear as an expression) like<pre>
   *   function Point(x, y) {
   *     this.x_ = x;
   *     this.y_ = y;
   * }</pre> into two function definitions and an initialization:<pre>
   * var Point = (function () {
   *     ___.splitCtor(Point, Point_init___);
   *     function Point(var_args) {
   *       return new Point.make___(arguments);
   *     }
   *     function Point_init___(x, y) {
   *       var t___ = this;
   *       (function () {
   *           var x___ = x;
   *           return t___.x__canSet___ ? (t___.x_ = x___) : ___.setProp(t___, 'x_', x___);
   *         })();
   *       (function () {
   *           var x___ = y;
   *           return t___.y__canSet___ ? (t___.y_ = x___) : ___.setProp(t___, 'y_', x___);
   *         })();
   *     }
   *     return Point;
   *   })();
   * </pre>
   * The result assigned to a variable of the same name (as above) if translating a 
   * declaration; the result is frozen instead if the function is in expression context.
   */
  function splitCtor(constr, initer, opt_Sup, opt_name) {
    ctor(constr, opt_Sup, opt_name);
    constr.init___ = initer;
    constr.make___ = function(args) {
      this.underConstruction___ = true;
      constr.init___.apply(this, args);
      delete this.underConstruction___;
      if (this.delayedTrademarks___) {
        this.trademarks___ = this.delayedTrademarks___;
        delete this.delayedTrademarks___;
      }
    };

    // We must preserve this identity, so anywhere that either
    // <tt>.prototype</tt> property might be assigned to, we must
    // assign to the other as well.
    constr.make___.prototype = constr.prototype;
    constr.call = function(that, var_args) {
      constr.init___.apply(that, Array.prototype.slice.call(arguments, 1));
    };
    return constr;
  }

  /**
   * Enables first-class methods.
   */
  function attach(that, meth) {
    if (typeof that !== 'function') {
      enforceType(that, 'object');
    }
    if (that === null) {
      fail('Internal: may not attach to null: ', meth);
    }
    if (!isMethod(meth)  && !isSimpleFunc(meth)) {
      fail('Internal: attach should not see non-methods: ', meth);
    }
    if (meth.___ATTACHMENT___ === that) {
      return meth;
    }
    if (meth.___ATTACHMENT___ !== undefined) {
      fail('Method ', meth, ' cannot be reattached to: ', that);
    }
    function result(var_args) {
      if (this !== that) {
        fail('Method ', meth, ' is already attached.\nthis: '+this+'\nthat: '+that);
      }
      return meth.apply(that, arguments);
    }
    var result = method(result, meth.___NAME___);
    result.___ATTACHMENT___ = that;
    result.___ORIGINAL___ = meth;
    return result;
  }

  /**
   * Marks an anonymous function as exophoric:
   * the function mentions <tt>this</tt>,
   * but only accesses the public interface.
   */
  function xo4a(func, opt_name) {
    enforceType(func, 'function', opt_name);
    func.___XO4A___ = true;
    return primFreeze(func);
  }

  /** 
   * Mark meth as a method.
   * <p>
   * @param opt_name if provided, should be the message name associated
   *   with the method. Currently, this is used only to generate
   *   friendlier error messages.
   */
  function method(meth, opt_name) {
    enforceType(meth, 'function', opt_name);
    if (isCtor(meth)) {
      fail("Constructors can't be methods: ", meth);
    }
    if (isSimpleFunc(meth)) {
      fail("Simple functions can't be methods: ", meth);
    }
    if (isXo4aFunc(meth)) {
      fail("Internal: exophoric functions can't be methods: ", meth);
    }
    meth.___METHOD___ = true;
    return primFreeze(meth);
  }

  /** 
   * Mark fun as a simple function.
   * <p>
   * opt_name, if provided, should be the name of the 
   * function. Currently, this is used only to generate friendlier
   * error messages.
   */
  function simpleFunc(fun, opt_name) {
    enforceType(fun, 'function', opt_name);
    if (isCtor(fun)) {
      fail("Constructors can't be simple functions: ", fun);
    }
    if (isMethod(fun)) {
      fail("Methods can't be simple function: ", fun);
    }
    fun.___SIMPLE_FUNC___ = true;
    fun.apply_canCall___ = true;
    fun.call_canCall___ = true;
    return fun;  // translator freezes fun later
  }
  
  /** This "Only" form doesn't freeze */
  function asCtorOnly(constr) {
    if (isCtor(constr) || isSimpleFunc(constr)) { 
      return constr; 
    }
    
    enforceType(constr, 'function');
    if (isMethod(constr)) {
      fail("Methods can't be called as constructors: ", constr);
    }
    fail("Untamed functions can't be called as constructors: ", constr);
  }
  
  /** Only constructors and simple functions can be called as constructors */
  function asCtor(constr) {
    return primFreeze(asCtorOnly(constr)); 
  }
  
  /** Only methods and simple functions can be called as methods */
  function asMethod(meth) {
    if (isSimpleFunc(meth) || isMethod(meth)) { 
      if (!isFrozen(meth)) {
        fail('internal: non-frozen func stored as method: ', meth);
      }
      return meth; 
    }
    
    enforceType(meth, 'function');
    if (isCtor(meth)) {
      fail("Constructors can't be called as methods: ", meth);
    }
    fail("Untamed functions can't be called as methods: ", meth);
  }
  
  /** Only simple functions can be called as simple functions */
  function asSimpleFunc(fun) {
    if (isSimpleFunc(fun)) { 
      return primFreeze(fun); 
    }
    
    enforceType(fun, 'function');
    if (isCtor(fun)) {
      if (fun === Number || fun === String || fun === Boolean) {
        // TODO(erights): To avoid accidents, <tt>method</tt>,
        // <tt>simpleFunc</tt>, and <tt>ctor</tt> each ensure that
        // these classifications are exclusive. A function can be
        // classified as in at most one of these categories. However,
        // some primordial type conversion functions like
        // <tt>String</tt> need to be invocable both ways, so we
        // should probably relax this constraint.
        // <p>
        // But before we do, we should reexamine other
        // implications. For example, simple-functions, when called
        // reflectively by <tt>call</tt> or <tt>apply</tt> (and
        // therefore <tt>bind</tt>), ignore their first argument,
        // whereas constructors can be called reflectively by
        // <tt>call</tt> to do super-initialization on behalf of a
        // derived constructor.
        // <p>
        // Curiously, ES3 also defines function behavior different
        // from constructor behavior for <tt>Object</tt>,
        // <tt>Date</tt>, <tt>RegExp</tt>, and <tt>Error</tt>. (Not
        // sure about <tt>Array</tt>.) We should understand these as
        // well before introducing a proper solution.
        return fun;
      }
      fail("Constructors can't be called as simple functions: ", fun);
    }
    if (isMethod(fun)) {
      // If it's an attached method, it can't be called on the wrong object.
      if (fun.___ATTACHMENT___) {
        return fun;
      }
      fail("Methods can't be called as simple functions: ", fun);
    }
    if (isXo4aFunc(fun)) {
      fail("Exophoric functions can't be called as simple functions: ", fun);
    }
    fail("Untamed functions can't be called as simple functions: ", fun);
  }
  
  /** Only simple and exophoric functions can be called as exophoric functions */
  function asXo4aFunc(fun) {
    if (isXo4aFunc(fun)) { 
      return fun; 
    }
    return asSimpleFunc(fun);
  }
  
  /** 
   * Sets constr.prototype[name] = member.
   * <p>
   * If member is a method of constr, make it callable.
   * If member is a simple function, make it callable and readable.
   * Else make it readable.
   */
  function setMember(constr, name, member) {
    name = String(name);
    if (endsWith(name, '__')) {
      fail('Reserved name: ', name);
    }
    var proto = asCtorOnly(constr).prototype;
    // We allow prototype members to end in a single "_".
    if (!canSetProp(proto, name)) {
      fail('not settable: ', name);
    }
    if (isMethod(member) || isXo4aFunc(member)) {
      fastpathCall(proto, name);
      fastpathEnumOnly(proto, name);
    } else if (isSimpleFunc(member)) {
      fastpathCall(proto, name);
      fastpathRead(proto, name);
      fastpathEnum(proto, name);
    } else {
      fastpathRead(proto, name);
      fastpathEnum(proto, name);
    }
    proto[name] = member;
  }
  
  ////////////////////////////////////////////////////////////////////////
  // Accessing properties
  ////////////////////////////////////////////////////////////////////////
  
  /** 
   * Can a constructed Caja object read this property on itself? 
   * <p>
   * Can a Caja method whose <tt>this</tt> is bound to <tt>that</tt>
   * read its own <tt>name</tt> property? For properties added to
   * the object by Caja code, the answer is yes. For other
   * properties, which must therefore be inherited from a prototype
   * written in Javascript rather than Caja, the answer is: iff they
   * were whitelisted.
   */
  function canReadProp(that, name) {
    name = String(name);
    if (endsWith(name, '__')) { return false; }
    return canRead(that, name);
  }
  
  /** 
   * A constructed Caja object's attempt to read this property on
   * itself.
   * <p>
   * If it can't,  it reads <tt>undefined</tt> instead.
   */
  function readProp(that, name) {
    name = String(name);
    if (canReadProp(that, name)) { return that[name]; }
    if (canCall(that, name)) { return attach(that, that[name]); }
    return that.handleRead___(name, false);
  }

  /**
   * Can a Caja client of <tt>obj</tt> read its <name> property? 
   * <p>
   * If the property is Internal (i.e. ends in an '_'), then no.
   * If the property was defined by Caja code, then yes. If it was
   * whitelisted, then yes. Or if the property is an own property of
   * a JSON container, then yes.
   */
  function canReadPub(obj, name) {
    name = String(name);
    if (endsWith(name, '_')) { return false; }
    if (canRead(obj, name)) { return true; }
    if (!isJSONContainer(obj)) { return false; }
    if (!hasOwnProp(obj, name)) { return false; }
    fastpathRead(obj, name);
    return true;
  }

  /**
   * Caja code attempting to read a property on something besides
   * <tt>this</tt>.
   * <p>
   * If it can't and <tt>opt_shouldThrow</tt> is absent or 
   * false-ish, then <ttreadPub</tt> returns <tt>undefined</tt>
   * instead. But if <tt>opt_shouldThrow</tt> is true-ish, then
   * <tt>readPub</tt> throws <tt>ReferenceError</tt>, in order to
   * simulate an attempt to read a non-existent global variable.
   */
  function readPub(obj, name, opt_shouldThrow) {
    if ((typeof name) === 'number') { return obj[name]; }
    name = String(name);
    if (canReadPub(obj, name)) { return obj[name]; }
    if (canCall(obj, name)) { return attach(obj, obj[name]); }
    return obj.handleRead___(name, opt_shouldThrow);
  }

  /**
   * Privileged code attempting to read an imported value from a module's
   * <tt>IMPORTS___</tt>. This function is NOT available to Caja code.
   * <p>
   * This delegates to <tt>readPub</tt>.
   * TODO(ihab.awad): Make this throw a "module linkage error" so as to be
   * more informative, rather than just whatever readPub throws.
   */
  function readImports(module_imports, name) {
    java.lang.System.err.println('readImports(' + module_imports + ',' + name + ')');
    // TODO(ihab.awad): using readPub here throws an error; fix!!
    // return readPub(module_imports, name);
    return module_imports[name];
  }

  /**
   * Can "innocent" code enumerate the named property on this object?
   * <p>
   * "Innocent" code is code which we assume to be ignorant of Caja,
   * not to be actively hostile, but which may be buggy (and
   * therefore accidentally harmful or exploitable). This
   * corresponds to legacy code, such as libraries, that we decide
   * to run untranslated, perhaps hidden or tamed, but which needs
   * to co-exist smoothly with the Caja runtime.
   * <p>
   * An earlier version of canInnocentEnum() filtered out exactly those
   * names ending with a double underbar. It now filters out exactly
   * those names ending in a triple underbar. Caja code can't see names
   * ending in a double underbar, since existing platforms (like
   * Firefox) use such names for purposes that should be hidden from
   * Caja code. However, it is not up to Caja to shield innocent code
   * from seeing such platform properties. All the magic names Caja
   * adds for its own internal bookkeeping end in triple underbar, so
   * that is all we need to hide from innocent code.
   */
  function canInnocentEnum(obj, name) {
    name = String(name);
    if (endsWith(name, '___')) { return false; }
    return true;
  }
  
  /** 
   * Would a Caja for/in loop on <tt>this</tt> see this name? 
   * <p>
   * For properties defined in Caja, this is generally the same as
   * canReadProp. Otherwise according to whitelisting.
   */
  function canEnumProp(that, name) {
    name = String(name);
    if (endsWith(name, '__')) { return false; }
    return canEnum(that, name);
  }
  
  /** 
   * Would a Caja for/in loop by a client of obj see this name? 
   * <p>
   * For properties defined in Caja, this is generally the same as
   * canReadProp. Otherwise according to whitelisting.
   */
  function canEnumPub(obj, name) {
    name = String(name);
    if (endsWith(name, '_')) { return false; }
    if (canEnum(obj, name)) { return true; }
    if (!isJSONContainer(obj)) { return false; }
    if (!hasOwnProp(obj, name)) { return false; }
    fastpathEnum(obj, name);
    return true;
  }
  
  /**
   * Like canEnumPub, but allows only non-inherited properties.
   */
  function canEnumOwn(obj, name) {
    name = String(name);
    return hasOwnProp(obj, name) && canEnumPub(obj, name);
  }

  /**
   * Returns a new object whose only utility is its identity and (for
   * diagnostic purposes only) its name.
   */
  function Token(name) {
    return primFreeze({
          toString: primFreeze(simpleFunc(function() { return name; }))
        });
  }
  primFreeze(simpleFunc(Token));

  /**
   * Inside a <tt>caja.each()</tt>, the body function can terminate
   * early, as if with a conventional <tt>break;</tt>, by doing a
   * <pre>return caja.BREAK;</pre>
   */
  var BREAK = Token('BREAK');

  /**
   * For each sensible key/value pair in obj, call fn with that
   * pair.
   * <p>
   * If <tt>obj instanceof Array</tt>, then enumerate
   * indexes. Otherwise, enumerate the canEnumOwn() property names.
   */
  function each(obj, fn) {
    fn = asSimpleFunc(fn);
    if (obj && obj.constructor.typeTag___ === 'Array') {
      var len = obj.length;
      for (var i = 0; i < len; i++) {
        if (fn(i, readPub(obj, i)) === BREAK) {
          return;
        }
      }
    } else {
      for (var k in obj) {
        if (canEnumOwn(obj, k)) {
          if (fn(k, readPub(obj, k)) === BREAK) {
            return;
          }
        }
      }
    }
  }
  
  /**
   * Can this be called as an internal method?
   * <p>
   * For genuine methods, they are only callable if the canCall
   * attribute is set. Otherwise, if this property is readable and
   * holds a simple function, then it's also callable as a function,
   * which we can memoize.
   * <p>
   * SECURITY HAZARD TODO(erights): If a settable property is
   * first set to a 
   * simple function, which is then called, memoizing canCall, and
   * then set to some other kind of function which leaked (such as
   * an untamed function), then that other function can be
   * inappropriately called as a method on that. We currently
   * classify this as a hazard and not a bug per se, since no such
   * function value should ever leak into value space. If one does,
   * there's a bug either in Caja or in the embedding app's taming
   * decisions.
   * <p>
   * In any case, the not-yet-implemented plan to fix this hazard is
   * to have two canSet flags: one that records the grant of
   * settability, and one to be tested in the fast-path. The
   * fast-path canCall and fast-path canSet flags will be exclusive,
   * to be faulted in by the last successful use. This way, repeated
   * calls are fast, and repeated sets are fast, but the first call
   * after a set will re-check the value to be called.
   * <p>
   * This plan will need to be thought through again when we
   * implement property deletion. 
   */
  function canCallProp(that, name) {
    name = String(name);
    if (endsWith(name, '__')) { return false; }
    if (canCall(that, name)) { return true; }
    if (!canReadProp(that, name)) { return false; }
    var func = that[name];
    if (!isSimpleFunc(func)) { return false; }
    fastpathCall(that, name);
    return true;
  }
  
  /**
   * A Caja method tries to call one of its Internal methods.
   */
  function callProp(that, name, args) {
    name = String(name);
    if (canCallProp(that, name)) {
      var meth = that[name];
      return meth.apply(that, args);
    } else {
      return that.handleCall___(name, args);
    }
  }
  
  /**
   * Like canCallProp(), with differences that parallel the
   * differences between canReadProp vs canReadPub.
   */
  function canCallPub(obj, name) {
    name = String(name);
    if (endsWith(name, '_')) { return false; }
    if (canCall(obj, name)) { return true; }
    if (!canReadPub(obj, name)) { return false; }
    var func = obj[name];
    if (!isXo4aFunc(func) && !isMethod(func)) { return false; }
    fastpathCall(obj, name);
    return true;
  }
  
  /**
   * A client of obj tries to call one of its methods.
   */
  function callPub(obj, name, args) {
    name = String(name);
    if (canCallPub(obj, name)) {
      var meth = obj[name];
      return meth.apply(obj, args);
    }
    if (obj.handleCall___) { return obj.handleCall___(name, args); }
    fail('not callable %o %s', debugReference(obj), name);
  }

  /**
   * Can a method of a Caja constructed object directly assign to
   * this property of its object?
   * <p>
   * Iff this object is not frozen.
   */
  function canSetProp(that, name) {
    name = String(name);
    if (endsWith(name, '__')) { return false; }
    if (canSet(that, name)) { return true; }
    return !isFrozen(that);
  }

  /**
   * A Caja method tries to assign to this property of its object.
   */
  function setProp(that, name, val) {
    name = String(name);
    if (canSetProp(that, name)) {
      fastpathSet(that, name);
      if (!hasOwnProp(that, name)) {
        fastpathDelete(that, name);
      }
      return that[name] = val;
    } else {
      return that.handleSet___(name, val);
    }
  }
  
  /**
   * Can a client of obj directly assign to its name property?
   * <p>
   * If this property is Internal (i.e., ends with a '_') or if this
   * object is frozen, then no. 
   * If this property is not Internal and was defined by Caja code,
   * then yes. If the object is a JSON container, then
   * yes. Otherwise according to whitelisting decisions.
   * <p>
   * The non-obvious implication of this rule together with the
   * canSetProp rule is that a Caja client of a Caja constructed
   * object cannot add new properties to it. But a Caja constructed
   * object can add new properties to itself, and its clients can
   * then assign to these properties.
   */
  function canSetPub(obj, name) {
    name = String(name);
    if (endsWith(name, '_')) { return false; }
    if (canSet(obj, name)) { return true; }
    return !isFrozen(obj) && isJSONContainer(obj);
  }

  /** A client of obj attempts to assign to one of its properties. */
  function setPub(obj, name, val) {
    name = String(name);
    if (canSetPub(obj, name)) {
      fastpathSet(obj, name);
      obj[name] = val;
      return val;
    } else if (isCtor(obj) && !isFrozen(obj)) {
      // Handles
      //    ctor.staticMemberName = val;
      setStatic(obj, name, val);
    } else {
      return obj.handleSet___(name, val);
    }
  }

  /**
   * Can the given constructor have the given static method attached to it.
   * @param {Function} ctor
   * @param {string} staticMemberName an identifier in the public namespace.
   */
  function canSetStatic(ctor, staticMemberName) {
    staticMemberName = '' + staticMemberName;
    if (typeof ctor !== 'function') {
      log('Cannot set static member of non function', ctor);
      return false;
    }
    if (isFrozen(ctor)) {
      log('Cannot set static member of frozen function', ctor);
      return false;
    }
    if (staticMemberName in ctor) {  // disallows prototype, call, apply, bind
      log('Cannot override static member ', staticMemberName);
      return false;
    }
    if (endsWith(staticMemberName, '_')) {  // statics are public
      log('Illegal static member name ', staticMemberName);
      return false;
    }
    return true;
  }

  /**
   * Sets a static member of a ctor, making sure that it cannot be used to
   * override call/apply/bind and other builtin members of function.
   * @param {Function} ctor
   * @param {string} staticMemberName an identifier in the public namespace.
   * @param staticMemberValue the value of the static member.
   */
  function setStatic(ctor, staticMemberName, staticMemberValue) {
    staticMemberName = '' + staticMemberName;
    if (canSetStatic(ctor, staticMemberName)) {
      ctor[staticMemberName] = staticMemberValue;
      fastpathRead(ctor, staticMemberName);
    } else {
      fail('cannot set static member %o %s',
           debugReference(obj), staticMemberName);
    }
  }

  /**
   * Can a Caja constructed object delete the named property?
   */
  function canDeleteProp(obj, name) {
    name = String(name);
    if (isFrozen(obj)) { return false; }
    if (endsWith(name, '__')) { return false; }
    if (isJSONContainer(obj)) { return true; }
    return !!obj[name + '_canDelete___'];
  }

  /**
   * A Caja constructed object attempts to delete one of its own
   * properties.
   */
  function deleteProp(obj, name) {
    name = String(name);
    if (canDeleteProp(obj, name)) {
      // See deleteFieldEntirely for reasons why we don't cache deletability.
      return deleteFieldEntirely(obj, name);
    } else {
      return obj.handleDelete___(name);
    }
  }

  /**
   * Can a client of obj delete the named property?
   */
  function canDeletePub(obj, name) {
    name = String(name);
    if (isFrozen(obj)) { return false; }
    if (endsWith(name, '__')) { return false; }
    if (isJSONContainer(obj)) { return true; }
    return false;
  }

  /**
   * A client of obj can only delete a property of obj if obj is a
   * non-frozen JSON container.
   */
  function deletePub(obj, name) {
    name = String(name);
    if (canDeletePub(obj, name)) {
      // See deleteFieldEntirely for reasons why we don't cache deletability.
      return deleteFieldEntirely(obj, name);
    } else {
      return obj.handleDelete___(name);
    }
  }

  /**
   * Deletes a field removing any cached permissions.
   * @param {object} obj
   * @param {string} name of field in obj to delete.
   * @return {boolean}
   * @throws {Error} if field not deletable or name not in field.
   * @private
   */
  function deleteFieldEntirely(obj, name) {
    // Can't cache allow delete since deleting the field should remove
    // all privileges for that field.
    delete obj[name + '_canRead___'];
    delete obj[name + '_canEnum___'];
    delete obj[name + '_canCall___'];
    delete obj[name + '_canSet___'];
    delete obj[name + '_canDelete___'];
    return (delete obj[name]) || (fail('not deleted: ', name), false);
  }

  ////////////////////////////////////////////////////////////////////////
  // Other
  ////////////////////////////////////////////////////////////////////////

  /**
   * This returns a frozen array copy of the original array or
   * array-like object.
   * <p>
   * If a Caja program makes use of <tt>arguments</tt> in any
   * position other than <tt>arguments.callee</tt>, this is
   * rewritten to use a frozen array copy of arguments instead. This
   * way, if Caja code passes its arguments to someone else, they
   * are not giving the receiver the rights to access the passing
   * function nor to modify the parameter variables of the passing
   * function.
   */
  function args(original) {
    return primFreeze(Array.prototype.slice.call(original, 0));
  }

  /**
   * When a <tt>this</tt> value must be provided but nothing is
   * suitable, provide this useless object instead.
   */
  var USELESS = Token('USELESS');

  /** Sealer for call stacks as from {@code (new Error).stack}. */
  var callStackSealer = makeSealerUnsealerPair();

  /**
   * Receives the exception caught by a user defined catch block.
   * @param ex a value caught in a try block.
   * @return a tamed exception.
   */
  function tameException(ex) {
    try {
      switch (typeof ex) {
        case 'object':
          if (ex === null) { return null; }
          if (ex instanceof Error) {  // TODO: or the cross frame equivalent
            // See Ecma-262 S15.11 for the definitions of these properties.
            var message = ex.message || ex.desc;
            var stack = ex.stack;
            var name = ex.constructor && ex.constructor.name;  // S15.11.7.9
            // Convert to undefined if null or undefined, or a string otherwise.
            message = message == null ? void 0 : '' + message;
            stack = stack == null ? void 0 : callStackSealer.seal('' + stack);
            name = name == null ? void 0 : '' + name;
            return primFreeze({ message: message, name: name, stack: stack });
          }
          return '' + ex;
        case 'string':
        case 'number':
        case 'boolean':
        case 'undefined':
          // Immutable.
          return ex;
        case 'function':
          // According to Pratap Lakhsman's "JScript Deviations" S2.11
          // If the caught object is a function, calling it within the catch
          // supplies the head of the scope chain as the "this value".  The
          // called function can add properties to this object.  This implies
          // that for code of this shape:
          //     var x;
          //     try {
          //       // ...
          //     } catch (E) {
          //       E();
          //       return s;
          //     }
          // The reference to 'x' within the catch is not necessarily to the
          // local declaration of 'x'; this gives Catch the same performance
          // problems as with.

          // We return undefined to make sure that caught functions cannot be
          // evaluated within the catch block.
          return void 0;
        default:
          log('Unrecognized exception type ' + (typeof ex));
          return void 0;
      }
    } catch (_) {
      // Can occur if coercion to string fails, or if ex has getters that fail.
      // This function must never throw an exception because doing so would
      // cause control to leave a catch block before the handler fires.
      return void 0;
    }
  }

  /**
   *
   */
  function setMemberMap(sub, members) {
    each(members, simpleFunc(function(mname, member) {
      setMember(sub, mname, member);
    }));
  }

  /**
   * Provides a shorthand for a class-like declaration of a fresh
   * Caja constructor.
   * <p>
   * Given that sub is a Caja constructor in formation, whose 'prototype'
   * property hasn't been initialized yet, initialize sub and its
   * 'prototype' property so that it acts as a subclass of opt_Sup,
   * with opt_members added as members to sub.prototype, and
   * opt_statics added as members to sub.
   * <p>
   * TODO(erights): return a builder object that allows further
   * initialization.
   */
  function def(sub, opt_Sup, opt_members, opt_statics) {
    var sup = opt_Sup || Object;
    var members = opt_members || {};
    var statics = opt_statics || {};

    ctor(sub, sup);
    function PseudoSuper() {}
    PseudoSuper.prototype = sup.prototype;
    sub.prototype = new PseudoSuper();
    if (sub.make___) {
      // We must preserve this identity, so anywhere that either
      // <tt>.prototype</tt> property might be assigned to, we must
      // assign to the other as well.
      sub.make___.prototype = sub.prototype;
    }
    sub.prototype.constructor = sub;

    setMemberMap(sub, members);
    each(statics, simpleFunc(function(sname, staticMember) {
      setStatic(sub, sname, staticMember);
    }));

    // translator freezes sub and sub.prototype later.
  }

  ////////////////////////////////////////////////////////////////////////
  // Taming mechanism
  ////////////////////////////////////////////////////////////////////////

  /**
   * Arrange to handle read-faults on <tt>obj[name]</tt>
   * by calling <tt>getHandler(opt_shouldThrow)</tt> as a method on
   * the faulted object. 
   * <p>
   * In order for this fault-handler to get control, it's important
   * that no one does a conflicting <tt>allowRead()</tt>.
   */
  function useGetHandler(obj, name, getHandler) {
    obj[name + '_getter___'] = getHandler;
  }

  /**
   * Arrange to handle call-faults on <tt>obj[name](args...)</tt> by
   * calling <tt>applyHandler(args)</tt> as a method on the faulted
   * object. 
   * <p>
   * Note that <tt>applyHandler</tt> is called with a single argument,
   * which is the list of arguments in the original call.
   * <p>
   * In order for this fault-handler to get control, it's important
   * that no one does a conflicting allowCall(), allowSimpleFunc(), or
   * allowMethod().
   */
  function useApplyHandler(obj, name, applyHandler) {
    obj[name + '_handler___'] = applyHandler;
  }

  /**
   * Arrange to handle call-faults on <tt>obj[name](args...)</tt> by
   * calling <tt>callHandler(args...)</tt> as a method on the faulted
   * object. 
   * <p>
   * Note that <tt>callHandler</tt> is called with the same arguments
   * as the original call. 
   * <p>
   * In order for this fault-handler to get control, it's important
   * that no one does a conflicting allowCall(), allowSimpleFunc(), or
   * allowMethod().
   */
  function useCallHandler(obj, name, callHandler) {
    useApplyHandler(obj, name, function(args) {
      return callHandler.apply(this, args);
    });
  }

  /**
   * Arrange to handle set-faults on <tt>obj[name] = newValue</tt> by
   * calling <tt>setHandler(newValue)</tt> as a method on the faulted
   * object.  
   * <p>
   * In order for this fault-handler to get control, it's important
   * that no one does a conflicting allowSet().
   */
  function useSetHandler(obj, name, setHandler) {
    obj[name + '_setter___'] = setHandler;
  }

  /**
   * Arrange to handle delete-faults on <tt>delete obj[name]</tt> by
   * calling <tt>deleteHandler()</tt> as a method on the faulted object. 
   * <p>
   * In order for this fault-handler to get control, it's important
   * that no one does a conflicting allowDelete().
   */
  function useDeleteHandler(obj, name, deleteHandler) {
    obj[name + '_deleter___'] = deleteHandler;
  }

  /**
   * Whilelist obj[name] as a simple function that can be either
   * called or read.
   */
  function grantSimpleFunc(obj, name) {
    simpleFunc(obj[name], name);
    grantCall(obj, name);
    grantRead(obj, name);
  }
  
  /**
   * Whitelist constr.prototype[name] as a method that can be called
   * on instances of constr.
   */
  function grantMethod(constr, name) {
    method(constr.prototype[name], name);
    grantCall(constr.prototype, name);
  }
  
  function useGetAndCallHandlers(constr, name, func) {
    useGetHandler(constr, name, function() { return func; });
    useCallHandler(constr, name, func);
  }
  
  /**
   * Virtually replace constr.prototype[name] with a fault-handler
   * wrapper that first verifies that <tt>this</tt> isn't frozen.
   * <p>
   * When a pre-existing Javascript method would mutate its object,
   * we need to provide a fault handler instead to prevent such
   * mutation from violating Caja semantics. In order for this fault
   * handler to get control, it's important that no one does an
   * allowCall(), allowSimpleFunc(), or allowMethod() on the
   * original method. 
   */
  function grantMutator(constr, name) {
    var original = constr.prototype[name];
    useGetAndCallHandlers(constr.prototype, name, xo4a(function(var_args) {
      if (isFrozen(this)) {
        fail("Can't .", name, ' a frozen object');
      }
      return original.apply(this, arguments);
    }));
  }
  
  /**
   * Verifies that regexp is something that can appear as a
   * parameter to a Javascript method that would use it in a match.
   * <p>
   * If it is a RegExp, then this match might mutate it, which must
   * not be allowed if regexp is frozen.
   */
  function enforceMatchable(regexp) {
    if (regexp instanceof RegExp) {
      if (isFrozen(regexp)) {
        fail("Can't match with frozen RegExp: ", regexp);
      }
    }
  }
  
  /**
   * A shorthand that happens to be useful here.
   * <p>
   * For all i in arg2s: func2(arg1,arg2s[i]).
   */
  function all2(func2, arg1, arg2s) {
    var len = arg2s.length;
    for (var i = 0; i < len; i += 1) {
      func2(arg1, arg2s[i]);
    }
  }
  
  ////////////////////////////////////////////////////////////////////////
  // Taming decisions
  ////////////////////////////////////////////////////////////////////////

  all2(grantRead, Math, [
    'E', 'LN10', 'LN2', 'LOG2E', 'LOG10E', 'PI', 'SQRT1_2', 'SQRT2'
  ]);
  all2(grantSimpleFunc, Math, [
    'abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor',
    'log', 'max', 'min', 'pow', 'random', 'round', 'sin', 'sqrt', 'tan'
  ]);


  ctor(Object, (void 0), 'Object');
  all2(grantMethod, Object, [
    'toString', 'toLocaleString', 'valueOf', 'isPrototypeOf'
  ]);
  grantRead(Object.prototype, 'length');
  useGetAndCallHandlers(Object.prototype, 'hasOwnProperty', xo4a(function(name){
    name = String(name);
    return canReadPub(this, name) && hasOwnProp(this, name);
  }));
  useGetAndCallHandlers(
      Object.prototype, 
      'propertyIsEnumerable', 
      xo4a(function(name) {
        name = String(name);
        return canReadPub(this, name) && 
            Object.prototype.propertyIsEnumerable.call(this, name);
  }));

  /**
   * A method of a constructed object can freeze its object by saying
   * <tt>this.freeze_()</tt>.
   * <p>
   * Because this method ends in a "_", it is internal, so clients
   * of a constructed object (a non-JSON container) cannot freeze it
   * without its cooperation.
   */
  useGetAndCallHandlers(Object.prototype, 'freeze_', method(function() {
    return primFreeze(this);
  }));
  
  useGetAndCallHandlers(Object.prototype, 'apply', xo4a(function(that, realArgs) {
    return asXo4aFunc(this).apply(that, realArgs);
  }));
  useGetAndCallHandlers(Object.prototype, 'call', xo4a(function(that, realArgs) {
    return asXo4aFunc(this).apply(that, Array.prototype.slice.call(arguments, 1));
  }));

  ctor(Array, Object, 'Array');
  all2(grantMethod, Array, [
    'concat', 'join', 'slice', 'indexOf', 'lastIndexOf'
  ]);
  all2(grantMutator, Array, [
    'pop', 'push', 'reverse', 'shift', 'splice', 'unshift'
  ]);
  useGetAndCallHandlers(Array.prototype, 'sort', xo4a(function(comparator) {
    if (isFrozen(this)) {
      fail("Can't sort a frozen array.");
    }
    if (comparator) {
      return Array.prototype.sort.call(this, ___.asSimpleFunc(comparator));
    } else {
      return Array.prototype.sort.call(this);
    }
  }));

  ctor(String, Object, 'String');
  grantSimpleFunc(String, 'fromCharCode');
  all2(grantMethod, String, [
    'charAt', 'charCodeAt', 'concat', 'indexOf', 'lastIndexOf',
    'localeCompare', 'slice', 'substr', 'substring',
    'toLowerCase', 'toLocaleLowerCase', 'toUpperCase', 'toLocaleUpperCase'
  ]);
  
  useGetAndCallHandlers(String.prototype, 'match', xo4a(function(regexp) {
    enforceMatchable(regexp);
    return this.match(regexp);
  }));
  useGetAndCallHandlers(
      String.prototype, 
      'replace', 
      xo4a(function(searchValue, replaceValue) {
        enforceMatchable(searchValue);
        return this.replace(
            searchValue,
            (typeof replaceValue === 'function'
             ? ___.asSimpleFunc(replaceValue)
             : '' + replaceValue));
  }));
  useGetAndCallHandlers(String.prototype, 'search', xo4a(function(regexp) {
    enforceMatchable(regexp);
    return this.search(regexp);
  }));
  useGetAndCallHandlers(String.prototype, 'split', xo4a(function(separator, limit) {
    enforceMatchable(separator);
    return this.split(separator, limit);
  }));
  
  
  ctor(Boolean, Object, 'Boolean');
  
  
  ctor(Number, Object, 'Number');
  all2(grantRead, Number, [
    'MAX_VALUE', 'MIN_VALUE', 'NaN',
    'NEGATIVE_INFINITY', 'POSITIVE_INFINITY'
  ]);
  all2(grantMethod, Number, [
    'toFixed', 'toExponential', 'toPrecision'
  ]);
  
  
  ctor(Date, Object, 'Date');
  grantSimpleFunc(Date, 'parse');
  grantSimpleFunc(Date, 'UTC');
  
  all2(grantMethod, Date, [
    'toDateString', 'toTimeString', 'toUTCString',
    'toLocaleString', 'toLocaleDateString', 'toLocaleTimeString',
    'toISOString',
    'getDay', 'getUTCDay', 'getTimezoneOffset',
    
    'getTime', 'getFullYear', 'getUTCFullYear', 'getMonth', 'getUTCMonth',
    'getDate', 'getUTCDate', 'getHours', 'getUTCHours',
    'getMinutes', 'getUTCMinutes', 'getSeconds', 'getUTCSeconds',
    'getMilliseconds', 'getUTCMilliseconds'
  ]);
  all2(grantMutator, Date, [
    'setTime', 'setFullYear', 'setUTCFullYear', 'setMonth', 'setUTCMonth',
    'setDate', 'setUTCDate', 'setHours', 'setUTCHours',
    'setMinutes', 'setUTCMinutes', 'setSeconds', 'setUTCSeconds',
    'setMilliseconds', 'setUTCMilliseconds'
  ]);
  
  
  ctor(RegExp, Object, 'RegExp');
  grantMutator(RegExp, 'exec');
  grantMutator(RegExp, 'test');
  
  all2(grantRead, RegExp, [
    'source', 'global', 'ignoreCase', 'multiline', 'lastIndex'
  ]);

  grantMethod(Function, 'bind');  
  
  ctor(Error, Object, 'Error');
  grantRead(Error, 'name');
  grantRead(Error, 'message');
  ctor(EvalError, Error, 'EvalError');
  ctor(RangeError, Error, 'RangeError');
  ctor(ReferenceError, Error, 'ReferenceError');
  ctor(SyntaxError, Error, 'SyntaxError');
  ctor(TypeError, Error, 'TypeError');
  ctor(URIError, Error, 'URIError');
  
  
  var sharedImports;
  
  ////////////////////////////////////////////////////////////////////////
  // Module loading
  ////////////////////////////////////////////////////////////////////////
  
  var myNewModuleHandler;
  
  /**
   * Gets the current module handler.
   */
  function getNewModuleHandler() {
    return myNewModuleHandler;
  }
  
  /**
   * Registers a new-module-handler, to be called back when a new
   * module is loaded.
   * <p>
   * This callback mechanism is provided so that translated Caja
   * modules can be loaded from a trusted site with the
   * &lt;script&gt; tag, which runs its script as a statement, not
   * an expression. The callback is of the form
   * <tt>moduleHandler.handle(newModule)</tt>.
   */
  function setNewModuleHandler(newModuleHandler) {
    myNewModuleHandler = newModuleHandler;
  }
  
  /**
   * A new-module-handler which does nothing.
   */
  var ignoreNewModule = freeze({
    handle: simpleFunc(function(newModule){})
  });
  
  /**
   * Makes and returns a fresh "normal" module handler whose imports
   * are initialized to a copy of the sharedImports.
   * <p>
   * This handles a new module by calling it, passing it the imports
   * object held in this handler. Successive modules handled by the
   * same "normal" handler thereby see a simulation of successive
   * updates to a shared global scope.
   */
  function makeNormalNewModuleHandler() {
    var imports = copy(sharedImports);
    return freeze({
      getImports: simpleFunc(function() { return imports; }),
      setImports: simpleFunc(function(newImports) { imports = newImports; }),
      handle: simpleFunc(function(newModule) {
        imports.caja = caja;
        newModule(___, imports);
      })
    });
  }
  
  /**
   * A module is a plugin-maker function.
   * <p>
   * loadModule(module) marks module as a simpleFunc, freezes it,
   * asks the current new-module-handler to handle it (thereby
   * notifying the handler), and returns the new module.  
   */
  function loadModule(module) {
    callPub(myNewModuleHandler, 'handle', [primFreeze(simpleFunc(module))]);
    return module;
  }

  var registeredImports = [];

  /**
   * Gets or assigns the id associated with this (assumed to be)
   * imports object, registering it so that 
   * <tt>getImports(getId(imports)) ==== imports</tt>.
   * <p>
   * This system of registration and identification allows us to
   * cajole html such as
   * <pre>&lt;a onmouseover="alert(1)"&gt;Mouse here&lt;/a&gt;</pre>
   * into html-writing JavaScript such as<pre>
   * ___IMPORTS___.document.innerHTML = "
   *  &lt;a onmouseover=\"
   *    (function(___IMPORTS___) {
   *      ___IMPORTS___.alert(1);
   *    })(___.getImports(" + ___.getId(___IMPORTS___) + "))
   *  \"&gt;Mouse here&lt;/a&gt;
   * ";
   * </pre>
   * If this is executed by a plugin whose imports is assigned id 42,
   * it generates html with the same meaning as<pre>
   * &lt;a onmouseover="___.getImports(42).alert(1)"&gt;Mouse here&lt;/a&gt;
   * </pre>
   * <p>
   * An imports is not registered and no id is assigned to it until the
   * first call to <tt>getId</tt>. This way, an imports that is never
   * registered, or that has been <tt>unregister</tt>ed since the last
   * time it was registered, will still be garbage collectable.
   */
  function getId(imports) {
    enforceType(imports, 'object', 'imports');
    var id;
    if ('id___' in imports) {
      id = enforceType(imports.id___, 'number', 'id');
    } else {
      id = imports.id___ = registeredImports.length;
    }
    registeredImports[id] = imports;
    return id;
  }

  /**
   * Gets the imports object registered under this id.
   * <p>
   * If it has been <tt>unregistered</tt> since the last
   * <tt>getId</tt> on it, then <tt>getImports</tt> will fail.
   */
  function getImports(id) {
    var result = registeredImports[enforceType(id, 'number', 'id')];
    if (result === (void 0)) {
      fail('imports#', id, ' unregistered');
    }
    return result;
  }

  /**
   * If you know that this <tt>imports</tt> no longers needs to be
   * accessed by <tt>getImports</tt>, then you should
   * <tt>unregister</tt> it so it can be garbage collected.
   * <p>
   * After unregister()ing, the id is not reassigned, and the imports
   * remembers its id. If asked for another <tt>getId</tt>, it
   * reregisters itself at its old id.
   */
  function unregister(imports) {
    enforceType(imports, 'object', 'imports');
    if ('id___' in imports) {
      var id = enforceType(imports.id___, 'number', 'id');
      registeredImports[id] = (void 0);
    }
  }

  
  ////////////////////////////////////////////////////////////////////////
  // Trademarking
  ////////////////////////////////////////////////////////////////////////

  // Any object may be used as a trademark.

  /**
   * Returns true if the object has a list of trademarks
   * and the given trademark is in the list.
   */
  function hasTrademark(trademark, obj) {
    if (!hasOwnProp(obj, "trademarks___")) { return false; }
    var list = obj.trademarks___;
    for (var i=0; i < list.length; ++i) {
      if (list[i]===trademark) { return true; }
    }
    return false;
  }

  /**
   * Throws an exception if the object does not have any trademarks or
   * the given trademark is not in the list of trademarks.
   */
  function guard(trademark, obj) {
    enforce (hasTrademark(trademark, obj),
        "This object does not have the given trademark" );
  }

  /**
   * This function adds the given trademark to the given object's list of
   * trademarks.
   * If the map doesn't exist yet, this function creates it.
   * If the object is still being constructed, it delays the trademarking.
   */
  function audit(trademark, obj) {
    enforce (typeof trademark === 'object',
        'The supplied trademark is not an object.'); 
    var list = obj.underConstruction___ ?
        "delayedTrademarks___" : "trademarks___";
    if (!obj[list]) { obj[list] = []; }
    obj[list].push(trademark);
  }


  ////////////////////////////////////////////////////////////////////////
  // Sealing and Unsealing
  ////////////////////////////////////////////////////////////////////////
  /**
   * Returns a pair of functions such that the seal(x) wraps x in an object
   * so that only unseal can get x back from the object.
   *
   * @return {object} of the form
   *     { seal: function (x) { return {}; },
   *       unseal: function (obj) { return x; } }.
   */
  function makeSealerUnsealerPair() {
    var flag = false;  // Was a box successfully unsealed
    var squirrel = null;  // Receives the payload from an unsealed box.
    function seal(payload) {
      function box() {
        flag = true, squirrel = payload;
      }
      box.toString = primFreeze(simpleFunc(function () { return '(box)'; }));
      return primFreeze(simpleFunc(box));
    }
    function unseal(box) {
      // Start off in a known good state.
      flag = false;
      squirrel = null;
      try {  // Don't do anything outside try to foil forwarding functions.
        asSimpleFunc(box)();
        if (!flag) { throw new Error('Sealer/Unsealer mismatch'); }
        return squirrel;
      } finally {
        // Restore to a known good state.
        flag = false;
        squirrel = null;
      }
    }
    return freeze({ seal: seal, unseal: unseal });
  }


  ////////////////////////////////////////////////////////////////////////
  // Exports
  ////////////////////////////////////////////////////////////////////////
  
  caja = {
    // Diagnostics and condition enforcement
    getLogFunc: getLogFunc, 
    setLogFunc: setLogFunc,
    log: log,

    fail: fail,
    enforce: enforce,
    enforceType: enforceType,
    enforceNat: enforceNat,
    
    // walking prototype chain, checking JSON containers
    isJSONContainer: isJSONContainer,
    freeze: freeze,
    copy: copy,
    snapshot: snapshot,
    
    // Accessing properties
    canReadPub: canReadPub,       readPub: readPub,
    canEnumPub: canEnumPub,
    canEnumOwn: canEnumOwn,       
    canInnocentEnum: canInnocentEnum,
    BREAK: BREAK,                 each: each,                   
    canCallPub: canCallPub,       callPub: callPub,
    canSetPub: canSetPub,         setPub: setPub,
    canDeletePub: canDeletePub,   deletePub: deletePub,

    // Trademarking
    hasTrademark: hasTrademark,
    guard: guard,
    audit: audit,

    // Sealing & Unsealing
    makeSealerUnsealerPair: makeSealerUnsealerPair,

    // Other
    def: def,
    USELESS: USELESS
  };

  sharedImports = {
    caja: caja,

    'null': null,
    'false': false,
    'true': true,
    'NaN': NaN,
    'Infinity': Infinity,
    'undefined': (void 0),
    parseInt: simpleFunc(parseInt),
    parseFloat: simpleFunc(parseFloat),
    isNaN: simpleFunc(isNaN),
    isFinite: simpleFunc(isFinite),
    decodeURI: simpleFunc(decodeURI),
    decodeURIComponent: simpleFunc(decodeURIComponent),
    encodeURI: simpleFunc(encodeURI),
    encodeURIComponent: simpleFunc(encodeURIComponent),
    Math: Math,

    Object: Object,
    Array: Array,
    String: String,
    Boolean: Boolean,
    Number: Number,
    Date: Date,
    RegExp: RegExp,

    Error: Error,
    EvalError: EvalError,
    RangeError: RangeError,
    ReferenceError: ReferenceError,
    SyntaxError: SyntaxError,
    TypeError: TypeError,
    URIError: URIError
  };

  each(sharedImports, simpleFunc(function(k, v) {
    switch (typeof v) {
    case 'object':
      if (v !== null) { primFreeze(v); }
      break;
    case 'function':
      primFreeze(v);
      break;
    }
  }));
  primFreeze(sharedImports);

  ___ = {
    // Privileged fault handlers
    getKeeper: getKeeper,
    setKeeper: setKeeper,

    // walking prototype chain, checking JSON containers
    directConstructor: directConstructor,
    isFrozen: isFrozen,
    primFreeze: primFreeze,

    // Accessing property attributes. allow* temporary for back compatibility
    canRead: canRead,        allowRead: grantRead,     grantRead: grantRead,
    canEnum: canEnum,        allowEnum: grantEnum,     grantEnum: grantEnum,
    canCall: canCall,        allowCall: grantCall,     grantCall: grantCall,
    canSet: canSet,          allowSet: grantSet,       grantSet: grantSet,
    canDelete: canDelete,    allowDelete: grantDelete, grantDelete: grantDelete,

    // Module linkage
    readImports: readImports,

    // Classifying functions
    isCtor: isCtor,
    isMethod: isMethod,
    isSimpleFunc: isSimpleFunc,
    isXo4aFunc: isXo4aFunc,
    ctor: ctor,                   asCtorOnly: asCtorOnly,
    asCtor: asCtor,
    splitCtor: splitCtor,
    method: method,               asMethod: asMethod,
    simpleFunc: simpleFunc,       asSimpleFunc: asSimpleFunc,
    xo4a: xo4a,
    setMember: setMember,
    setMemberMap: setMemberMap,
    attach: attach,

    // Accessing properties
    canReadProp: canReadProp,     readProp: readProp,
    canEnumProp: canEnumProp,
    canCallProp: canCallProp,     callProp: callProp,
    canSetProp: canSetProp,       setProp: setProp,
    canSetStatic: canSetStatic,   setStatic: setStatic,
    canDeleteProp: canDeleteProp, deleteProp: deleteProp,

    // Other
    hasOwnProp: hasOwnProp,
    args: args,
    tameException: tameException,
    callStackUnsealer: callStackSealer.unseal,
    RegExp: RegExp,  // Available to rewrite rule w/o risk of masking

    // Taming mechanism
    useGetHandler: useGetHandler,
    useApplyHandler: useApplyHandler,
    useCallHandler: useCallHandler,
    useSetHandler: useSetHandler,
    useDeleteHandler: useDeleteHandler,

    allowSimpleFunc: grantSimpleFunc,
    allowMethod: grantMethod,
    allowMutator: grantMutator,
    grantSimpleFunc: grantSimpleFunc,
    grantMethod: grantMethod,
    grantMutator: grantMutator,
    
    enforceMatchable: enforceMatchable,
    all2: all2,

    // Taming decisions
    sharedImports: sharedImports,

    // Module loading
    getNewModuleHandler: getNewModuleHandler,
    setNewModuleHandler: setNewModuleHandler,
    ignoreNewModule: ignoreNewModule,
    makeNormalNewModuleHandler: makeNormalNewModuleHandler,
    loadModule: loadModule,

    getId: getId,
    getImports: getImports,
    unregister: unregister
  };

  each(caja, simpleFunc(function(k, v) {
    if (k in ___) {
      fail('internal: initialization conflict: ', k);
    }
    if (typeof v === 'function') {
      simpleFunc(v);
      grantCall(caja, k);
    }
    ___[k] = v;
  }));
  setNewModuleHandler(makeNormalNewModuleHandler());
})(this);
