%% Copyright (C) 2007 Google Inc.
%%	
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%% http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%% ...........................................................................

%\documentclass[letterpaper,onecolumn,10pt]{article}
\documentclass[letterpaper,twocolumn,10pt]{article}

\usepackage{graphics}
\usepackage{hyperref}
\usepackage{alltt}
\usepackage{color}
\newcommand{\myurl}[1]{{\href{http://#1}{\texttt{#1}}}}
\newcommand{\myurlt}[2]{{\href{http://#1~#2}{\tt #1{\twiddle}#2}}}
\newcommand{\myurlh}[3]{{\href{http://#1#3}{\tt #1#2#3}}}

\definecolor{darkgray}{gray}{0.2}
\newcommand{\rem}[1]{{\textcolor{darkgray}{{\rm #1}}}}
\newcommand{\q}[1]{{\includegraphics{#1}}}
\newcommand{\qq}[2]{{\includegraphics{#1}}$\rightarrow${\includegraphics{#2}}}

%% Literal code-like strings in normal text.
\newcommand{\code}[1]{{\tt {#1}}}              % code

%don't want date printed
% \date{}

\sloppypar

\title{Caja\\
Safe active content in sanitized JavaScript}
\author{
        {\rm Mark S. Miller}
        \and 
        {\rm Mike Samuel}
        \and 
        {\rm Ben Laurie}
        \and 
        {\rm Ihab Awad}
        \and 
        {\rm Mike Stay}}


\begin{document}

\maketitle

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
% \thispagestyle{empty}
% \pagestyle{empty}

\abstract

Using Caja, web apps can safely allow scripts in third party content.

The computer industry has only one significant success enabling documents to 
carry active content safely: scripts in web pages. Normal users regularly 
browse untrusted sites with JavaScript turned on. Modulo browser bugs and 
phishing, they mostly remain safe. But even though web apps build on this 
success, they fail to provide its power. Web apps generally remove scripts 
from third party content, reducing content to passive data. Examples include 
webmail, groups, blogs, chat, docs and spreadsheets, wikis, and more; whether 
from Google, Yahoo, Microsoft, HP, Wikipedia, or others.

Were scripts in an object-capability language, web apps could provide active 
content safely, simply, and flexibly. Surprisingly, this is possible within 
existing web standards. Caja represents our discovery that a subset of 
JavaScript is an object-capability language.

\section{Introduction}

In a memory-safe object language such as JavaScript, object A can only invoke 
object B if A has a reference to B. If A already has references to B and C, A 
can invoke B passing C as an argument, giving B access to C. Memory-safe 
object language with encapsulation, such as Java, \emph{protect objects from 
their outside world}. The clients of an encapsulated object can make requests 
using its public interface. But how an object reacts to a request is up to 
the object. An encapsulated object can ensure that causality can only enter 
it according to the object model of computation.

An \emph{object-capability language} is essentially a memory-safe object 
language with encapsulation, with additional restrictions that \emph{protect 
the outside world from the objects}.\footnote{
%
Thanks to Mark Lillibridge for this formulation.
%
} In an object-capability language, an object can only cause effects outside 
itself by using the references it holds to other objects. Objects have no 
powerful references by default, and are granted new references only by normal 
message passing rules. Object references thereby become the sole 
representation of rights to affect the world, and normal message passing is 
the only rights transfer mechanism. An object can be denied authority simply 
by not giving it those references which would provide that authority.

The browser sandbox already mostly protects the world outside the browser 
from scripts running on web pages. A great virtue of JavaScript is that many 
people successfully program in it casually, without first learning the 
language in any depth. Caja\footnote{
%
\emph{Caja}, pronounced ``KA-hah'', is Spanish for ``box''. With Caja, 
\textbf{c}apabilities \textbf{a}ttenuate \textbf{J}avaScript 
\textbf{a}uthority.
%
} is an enforced subset of JavaScript we designed to make as little impact as 
possible on regular JavaScript programming, while still providing 
object-capability security. In this section, we provide a brief inaccurate 
overview of the differences between Caja and JavaScript suitable for the 
casual JavaScript programmer. The rest of this document then accurately goes 
into more depth.

\begin{description}

  \item[Forbidden names.] Caja rejects all names ending with ``\_\_'' (double 
  underscore). This gives the Caja implementation a place to store its 
  bookkeeping information where it is invisible to the Caja programmer.
 
  \item[Frozen objects.] If an object is frozen, an attempt to set, add, or 
  delete its properties will throw an exception instead. Functions and 
  prototypes are implicitly frozen. In addition, the Caja programmer can 
  explicitly freeze objects to prevent their direct modification. All objects 
  in the default global environment are \emph{immutable}, or transitively 
  frozen.
 
  \item[No shared global environment.] Each separately loaded module has its 
  own global environment which inherits from the default global environment, 
  isolating them from each other.

  \item[Internal names.] Property names ending in ``\_'' (single underscore) 
  serve as protected instance variables. Such names can only appear to the 
  right of ``\code{this.}''. As with Smalltalk instance variables or 
  \code{protected} instance variables in C++, these protected instance 
  variables are visible up and down the inheritance chain within an object, 
  but are not visible outside an object.
 
  \item[No method stealing.] The single underscore rule above only protects 
  an object's state from its clients if its clients cannot add methods to it 
  which alias its ``\code{this}''. Caja divides functions into three 
  categories: \emph{simple functions} are those which do not mention 
  ``\code{this}''. They are first-class and can be used without further 
  restriction. \emph{Constructors} are named functions which mention 
  ``\code{this}''. \emph{Methods} are anonymous function which mention 
  ``\code{this}''.

  Neither constructors nor methods are first-class. They can be used in ways 
  that support stereotyped class-like JavaScript programming patterns, but 
  they cannot be stored in variables or passed as arguments. Fortunately, 
  there's no loss of generality. For example, \code{F.make} in 
  Figure~\ref{fig:func-obj} wraps \code{F} in a simple function that can be 
  passed around freely.
 
  \item[Sharp knives removed.] Caja contains no ``\code{with}'' or 
  ``\code{eval}''. Caja includes a safe JSON library to support the most 
  common use of \code{eval}, and a safe \code{caja.eval} for evaluating code 
  in the \emph{Cajita} subset of Caja. Cajita is essentially the subset of
  Caja without ``\code{this}''. 
 
\end{description}

\begin{figure}[t!]
\begin{alltt}
function F(x) \{ this.x_ = x; \}
F.prototype.getX = function() \{
  return this.x_;
\};
F.make = function(x) \{
  return new F(x);
\};
function test() \{
  return new F(3).getX() === 3;
\}
\end{alltt}

\caption[Caja Functions]{Caja Functions. \code{F} is a \emph{constructor}. It 
can only be initialized and used with \code{new} and \code{instanceof}. 
\code{F.prototype.getX} is a \emph{method}. It can only be called as a 
method. \code{F.make} and \code{test} are \emph{simple functions}. They are
not restricted. \\ } \hrule
\label{fig:func-obj}
\end{figure}

Hopefully, this is all the casual Caja programmer needs to know to get 
started. Section~\ref{sec:epicycles} is a partisan history of access control 
on the web, in order to motivate the problems Caja addresses. It may safely 
be skipped. Section~\ref{sec:subset} explains the problems faced when 
securing JavaScript, many of which involve the use of ``\code{this}''.

We then present Caja in two stages. Section~\ref{sec:cajita-spec} presents 
\emph{Cajita}, the subset of Caja without ``\code{this}''. For new code, 
Cajita is a reasonably expressive language resembling an object-oriented 
Scheme. Section~\ref{sec:caja-spec} then presents the remainder of the Caja 
language beyond Cajita. Caja adds back enough of JavaScript for most old 
habits and old code to port pleasantly and painlessly. Caja and Cajita 
interoperate without problems. Section~\ref{sec:related} briefly 
surveys related work.



\section{Identity-centric Epicycles}
\label{sec:epicycles}

\begin{figure}[t!]
  \resizebox{\columnwidth}{!}{\includegraphics{seesaw-pola}}
  
\caption[The Evolving Authority of Active Content]{The Evolving Authority of 
Active Content. Identity-centric access controls have led to thrashing 
between lost functionality and lost safety. To have both, we need to provide 
\emph{least authority}: adequate authority for desired functionality without 
excess authority which invites abube. \\ } \hrule
  \label{fig:evo-auth}
\end{figure}

When a document contains live interactive programs, we say it contains 
\emph{active content}. The computer industry has spent over a billion dollars 
in failed attempts to support active content. But the success of web 
apps---themselves a form of active content---demonstrates that this dream was 
worth pursuing. Unfortunately, web developers today face a maze of complex 
security mechanisms that have, so far, prevented web apps themselves from 
supporting active content. To navigate our way out of this maze, we must 
first see how we got here.

Today's desktop operating systems all use some form of identity-centric 
access control~\cite{karp:abac-soa}, in which an installed application runs 
\emph{as} its user, and so is entrusted with all its user's authority. Such 
an application can provide its user all the functionality modern operating 
systems support, but at the price of being able to do anything its user may 
do. We depict this situation at~\q{2} on Figure~\ref{fig:evo-auth}. When you 
run Solitaire, it can delete all your files while playing within the rules of 
your system, without exploiting any bugs. (For the remainder of this 
document, we will ignore hazards due to implementation bugs, and explain only 
hazards due to architectural choices.)

At first, the documents handled by applications were safe passive data~\q{1}. 
Applications first supported active content by running scripts in documents 
with all of their user's authority~\qq{1}{2}. Excess authority invites abuse. 
Simply ``reading'' a malicious document would allow it to delete all your 
files. In reaction, installed office applications now encourage users to 
disable scripts (Figure~\ref{fig:dialog}) reducing content back to passive 
data~\qq{2}{1}. The failures of excess authority shown on the upper left thus 
led to the failures of inadequate authority shown on the lower right.

The web browser is itself an installed application that runs scripts in two 
contexts. Browser extensions run with all the user's authority~\q{2}. Scripts 
in web pages run sandboxed, with no authority to the user's local files. The 
browser's \emph{same origin policy}, another layer of identity-centric 
control~\cite{mashupos}, provides scripts with the authority to communicate 
with their site of origin~\qq{1}{3}. Regarding both decisions, the user is 
helpless. The user has no practical way to grant a script the authority to 
edit one of the user's local files, nor can the user deny a script the 
ability to call home. So long as the user's valuable assets were local, this 
model successfully protected the user.

\begin{figure}[t!]
  \resizebox{\columnwidth}{!}{\includegraphics{dialog}}
  
\caption[Only Bad Choices.]{Only Bad Choices. When documents contain scripts, 
users can disable themselves from getting any work done \q{1} or enable 
scripts to destroy all their other work \q{2}. \\ } \hrule
  \label{fig:dialog}
\end{figure}

Web apps leverage this success. To the browser, the page on which a web app 
resides is a document, and the web app itself is simply active content within 
that document. But to the user, a web app is an application managing yet 
other documents on the user's behalf. For example, when the user interacts 
with webmail, the documents of interest are email messages. Likewise for 
groups, blogs, chat, docs and spreadsheets, wikis, and more. Let us refer to 
the documents managed by web apps as \emph{passages}, to distinguish them 
from the web pages on which they appear.

Since the user can neither grant a web app access to local files nor deny it 
the ability to call home, the only place a web app could store these passages 
is on its site of origin. The browser security model protected the user's 
local files from being harmed \emph{or used}. As users shift to using web 
apps, the assets they value come to be the passages stored at these various 
origin sites. 

To protect their user's remote passages, web apps employed yet another layer 
of identity-centric controls, relying on cookies or other forms of 
authentication to identify their user. But when scripts within these passages 
ran, they would run within the web page containing the web app serving them, 
and were thereby authorized to do anything their web app could do on behalf 
of its user~\q{4}. For example, if a webmail application allowed HTML email 
messages to carry scripts, simply ``reading'' an incoming email message would 
allow it to delete your inbox. The~\qq{3}{4} transition is not a technical 
change, but a change in where the user's value resides, and thus a change in 
the user's risks. By this dynamic, failures of inadequate authority led to 
failures of excess authority.

To protect against malicious passages, some web apps do safely provide active 
content using \emph{iframes}---effectively nested web pages---at the cost of 
isolating themselves from this content~\qq{4}{3}~\cite{mashupos}. Most web 
apps \emph{sanitize} HTML content by removing all scripts, reducing content 
again to passive data~\qq{4}{1}. Existing HTML sanitizers disinfect the 
patient but leave a corpse. This recapitulates the loss of active content in 
installed office applications. Some proposals would address these next 
incremental problems by adding yet another identity-centric 
epicycle. Can we do better?

\begin{figure}[t!]
  \resizebox{\columnwidth}{!}{\includegraphics{epicycles}}

  \caption[Ptolemy's epicycles.]{Ptolemy's epicycles. Ptolemy attempted to
  model the motion of the heavenly bodies using only circles. With each
  discovery that the model didn't fit, yet another layer of circle was added
  to adjust. By contrast, Kepler's ellipses fit the problem directly, with no
  need for endless additional layers. 
  \\ } \hrule
  \label{fig:epicycle}
\end{figure}

If we could start over again, we could use an authorization-centric model 
such as object-capabilities~\cite{DVH}. The object-capability alternative 
naturally supports POLA, the principle of least authority, shown in the upper 
right of Figure~\ref{fig:evo-auth}. An object in an object-capability 
language can only cause effects by invoking the public interfaces of objects 
it can reach. An invocation provides references to other objects as 
arguments, providing the invoked object the least authority needed to carry 
out these requests~\cite{RobustComposition}. Within these rules, active 
content would run with exactly the authority explicitly provided by its 
containing document. Surprisingly, we can gain these benefits simply by 
applying a milder, non-lethal sanitizer.

Experience with Java, Scheme, OCaml, Pict, Perl and others demonstrates that 
existing memory safe languages often already contain an expressive 
object-capability subset~\cite[respectively]{joe-e, rees96security, emily, 
backwater, caperl}. We refer to the object-capability subset of JavaScript as 
\emph{Caja}. The Caja translator restricts the JavaScript it accepts to be 
within this subset. This sanitized JavaScript is still a general purpose 
object programming language which JavaScript programmers should find 
familiar, pleasant, expressive, and easy to learn and use.

Some web apps could use the Caja translator to allow active content in their 
passages~\qq{1}{5}. Other web apps could use Caja to overcome the limits of 
iframes~\qq{3}{5}. Browser extensions, which run with their user's full 
authority, could make a \emph{powerbox} available to scripts in 
pages~\cite{darpareview, stiegler:polaris, seaborn:plash, bitfrost}. A web 
app, on detecting the presence of a powerbox, could offer to edit a local 
file chosen by the user~\qq{4}{6}.

Our starting point is JavaScript 1.5 as documented in the third edition of 
the EcmaScript 262 standard~\cite{ECMA-262}; hereafter \emph{ES3}. The 
remainder of this document explains the differences between Caja---the 
JavaScript subset accepted by the Caja translator---and ES3. Other documents 
will explain the interface between Caja and untranslated JavaScript, and 
Caja's sanitization of the remaining elements of active web content: HTML, 
CSS, and the DOM and other APIs provided by browsers to JavaScript. We refer 
collectively to the subset of these accepted by the Caja translator as 
\emph{Caja web content}.


\section{Subsetting JavaScript}
\label{sec:subset}

\begin{figure}[t!]
\begin{alltt}
function Counter()\ \{
  var count = 0;
  return caja.freeze(\{
    toString: function()\ \{ 
      return "<counter: " + count + ">"; 
    \},
    incr: function()\ \{ 
      return count += 1; 
    \},
    decr: function()\ \{ 
      return count -= 1; 
    \}
  \});
\};
\end{alltt}

\caption[A Cajita Counter.]{A Cajita Counter. Each call to \code{Counter()} 
produces a new counter object. Access to a counter provides the authority to 
read, invoke, or enumerate its properties, all of which are simple functions 
serving the role of methods. Caja functions are implicitly frozen; the 
returned object is explicitly frozen; and the instance-state of the 
object---the count variable---is accessible only as encapsulated state 
captured by these pseudo-methods. A counter object as a whole, as well as 
each of its pseudo-methods, are thus proper protected capabilities. Someone 
with access only to a counter's \code{incr} function can increment 
\emph{that} counter and observe the result, but not do anything else.
% XXX Confusing. Needs clarification
 \\ } \hrule
\label{fig:cajita-counter}
\end{figure}

Caja defines a subset of JavaScript both syntactically and semantically. The 
Caja translator rejects non-Caja input statically when it can. But because of 
JavaScript's dynamic nature, some of Caja's restrictions cannot be imposed 
statically, so the Caja translator translates the JavaScript it accepts into 
JavaScript with additional runtime checks. To facilitate development, it is 
easy to write a program in the Caja subset of JavaScript so it can run 
correctly whether it is run translated or not.

A web app (or any other JavaScript-based embedding application framework) can 
be written partially in JavaScript and partially in Caja. The web app loads 
the Caja runtime library, which is written in JavaScript, and which is 
assumed by the JavaScript output of the Caja translator. All untrusted 
scripts must be provided as Caja source code, to be verified and translated 
by the Caja translator. The translator's output is either included directly 
in the containing web page or loaded by the Caja runtime.

A loose analogy with machine and operating system architecture should help 
explain the relationships. In the analogy, the full JavaScript language 
serves the role of the machine's full instruction set. JavaScript's global 
environment serves the role of physical memory addresses. The I/O-capable 
objects provided to JavaScript by a hosting environment, such as the DOM 
objects provided by the browser, serve the role of devices.

\begin{description}

  \item[User-mode.] By a combination of static and dynamic checks, the 
  translator allows only a safe ``user-mode'' subset of JavaScript. As with 
  user-mode instructions, this subset can compute any computable function, 
  but cannot cause external effects nor sense the outside world.

  \item[Address mapping.] A package of Caja source code to be translated 
  together defines a \emph{Caja module}. All code within the same module 
  share a global environment, but distinct modules see disjoint global 
  environments. The translator maps Caja global variable references to 
  instead address module-relative fields.

  \item[Context switching.] When Caja object A has a reference to Caja 
  object B, this should enable A to invoke B's public interface but not 
  access B's internal state. A and B should both be able to defend their 
  integrity from the other's possible misbehavior.

  \item[System calls, device drivers.] When a Caja object A invokes an 
  object B written directly in JavaScript, the operations provided by B serve 
  the role of system calls. Caja protects B from A, but A is fully 
  vulnerable to B. When B is a safe wrapper around one of the host's 
  device-like objects, such as a DOM node, B also serves as a device driver.

\end{description}

A ``system call'' corresponds to a Caja object invoking a JavaScript object. 
A web app that is written entirely in JavaScript and provides many services 
to its Caja objects directly would be like a monolithic kernel. For 
compatibility with existing JavaScript apps, we support this usage pattern 
but we don't recommend it. By analogy with kernel code at the boundary with 
untrusted code, such JavaScript code needs to maintain delicate invariants 
that it is easy to get wrong.

The other extreme is analogous to a micro-kernel. The minimal necessary 
JavaScript code would be the app-neutral Caja runtime itself, and a small 
app-dependent powerbox providing device drivers and initialization. All other 
services should be Caja objects to be invoked by other Caja objects. Most 
of the logic of a web app should be structured as such Caja-based services.

\subsection{JavaScript specific problems}

Most of the above remarks would apply equally well were we starting from 
various other base languages. There are additional issues peculiar to 
JavaScript that we must deal with. Many of these issues are also software 
engineering hazards for which JavaScript programmers have developed 
defensive programming conventions. Where possible, Caja copes with these 
issues by adapting and enforcing these existing conventions.

\begin{figure}[t!]
\begin{alltt}
function Point(x, y)\ \{
  return caja.freeze(\{
    toString: function()\ \{ 
      return "<" + x + "," + y + ">"; 
    \},
    getX: function()\ \{ return x; \},
    getY: function()\ \{ return y; \},
  \});
\};

var pt = Point(3, 5);
\end{alltt}

\caption[A Cajita Point.]{A Cajita Point. As a baseline, we first express 
this simple example in Cajita with no support for inheritance. Other 
elaborations will show how to support inheritance and various styles of 
definition in both Cajita and full Caja. 
\\ } \hrule
\label{fig:cajita-point}
\end{figure}

\begin{figure}[t!]
\begin{alltt}
function PointMixin(that, x, y)\ \{
  that.toString = function()\ \{ 
    return "<" + that.getX() + "," + 
                 that.getY() + ">"; 
  \};
  that.getX = function()\ \{ return x; \};
  that.getY = function()\ \{ return y; \};
  return that;
\}
function Point(x, y)\ \{
  return caja.freeze(PointMixin(\{\}, x, y));
\}
\end{alltt}

\caption[Cajita Inheritance.]{Cajita Inheritance. In the Cajita inheritance 
pattern, the equivalent of a non-final class is a function ending with 
``\code{Mixin}'' with \code{that} as its first parameter. The method-like 
functions can use \code{that} analogously to the use of \code{this} in full 
Caja, in order to refer to the overall object being defined. This 
``\code{*Mixin}'' function should only be called by ``subclasses'' such as 
WobblyPointMixin below. If the class is non-abstract, it should also have a 
pseudo-constructor function such as \code{Point} for making direct 
instances. \\ } \hrule
\label{fig:cajita-super-point}
\end{figure}

\begin{figure}[t!]
\begin{alltt}
function WobblyPointMixin(that)\ \{
  var super = caja.snapshot(that);
  that.getX = function()\ \{ 
    return Math.random() + super.getX(); 
  \};
  return that;
\}
function WobblyPoint(x, y)\ \{
  var that = PointMixin(\{\}, x, y));
  that = WobblyPointMixin(that);
  return caja.freeze(that);
\}
\end{alltt}

\caption[Cajita WobblyPointMixin.]{Cajita WobblyPointMixin. The equivalent of 
a non-final subclass is a ``\code{*Mixin}'' function with \code{that} as its 
first parameter, where the body calls \code{caja.snapshot} to make a frozen 
copy of the partially initialized \code{that} at that moment, to serve as the 
conventional \code{super} for the other functions defined within this scope. 
\\ } \hrule
\label{fig:cajita-super-wobbly-point} 
\end{figure}



\begin{description}

  \item[Unconstrained Properties.] JavaScript objects contain 
  \emph{properties}, i.e., named fields holding references to other objects. 
  JavaScript specifies that some properties are constrained to be 
  \emph{Internal}, \emph{ReadOnly}, \emph{DontEnum}, or \emph{DontDelete}. 
  Such constraints would help an object protect itself from its clients, but 
  JavaScript provides no way to express these constraints in the language. 
  Instead, any object defined in JavaScript is freely mutated by any other 
  object with access to it.
  
  \item[Global environment.] All JavaScript code executing within the same 
  JavaScript engine (such as a web page or iframe) implicitly share access to 
  the same global environment. Therefore, in JavaScript, objects cannot be 
  isolated from each other.

  \item[Implicit mutable state.] Some base JavaScript objects, such as 
  \code{Array.prototype}, are implicitly reachable even without naming any 
  global variable names. Even after global environment problems are fixed, 
  the mutability of these objects would prevent isolation.

  \item[Lack of encapsulation.] To support the ``context switching'' 
  criterion explained above, objects need to be able to encapsulate their 
  private state. JavaScript does provide one such mechanism: lexical 
  variables captured by lexical closures. However, using this as the sole 
  encapsulation mechanism for object patterns conflicts with existing 
  JavaScript programming practice.

  \item[``\code{this}'' what?] JavaScript's rules for binding ``\code{this}'' 
  depend on whether a function is invoked by \emph{construction}, by 
  \emph{method call}, by \emph{function call}, or by \emph{reflection}. If a 
  function written to be called in one way is instead called in another way, 
  its ``\code{this}'' might be rebound to a different object or even to the 
  global environment.

  \item[Foreign \code{for}/\code{in} loops.] JavaScript's 
  \code{for}/\code{in} loop enumerates the names of all an object's 
  properties, whether inherited or not, unless the property is DontEnum, 
  which the JavaScript programmer has no way to express. As a result, some of 
  these names need to be skipped by the loop body. Every JavaScript coding 
  style invents its own defensive pattern of additional tests to skip 
  unwanted property names.
    
  \item[Weak static analysis.] Although Caja is less dynamic than JavaScript, 
  we still assume that it is impractical to perform any interesting analysis, 
  such as type inference, both statically and safely. As a result, Caja's 
  static restrictions can only enforce simple syntactic rules. Remaining 
  restrictions must be enforced by runtime checks.
  
  \item[Fast path.] For the micro-kernel approach to be attractive, Caja's 
  extra runtime checks must not cost too much. Frequent operations, such as 
  property access using ``.'' must run close to full speed.
  
  \item[Uncontrolled language growth.] The ES3 spec allows one to add new 
  dangerous properties to core objects while claiming ES3 compatibility. 
  JavaScript language implementors, platform providers, and standards 
  committees make use of this freedom with unpredictable results. For 
  example, some JavaScript implementations have added dangerous properties, 
  like \code{eval}, to core objects, like \code{Object.prototype}. A safe 
  subset must deny access to these additional unknown properties. But since 
  these new properties are often DontEnum, there isn't even a reliable way to 
  detect them.
  
  \item[Browser compatibility.] Web content must work on widely deployed 
  browsers whether on not these browsers strictly conform to the relevant 
  standards. At the time of this writing, the plausible baseline platform is 
  the intersection of ES3, Firefox 1.5, Internet Explorer 6, Opera 9, Safari 
  3, and their successors. Fortunately, these browsers do conform quite 
  closely to ES3. Later versions of Caja may specify larger subsets of ES3.
  
  \item[Silent errors.] In JavaScript, various operations, such as setting a 
  ReadOnly property, fail silently rather than throwing an error. Program 
  logic then proceeds along normal control flow paths premised on the 
  assumption that these operations succeeded, leading to inconsistency. To 
  program defensively in the face of this hazard, every assignment would be 
  followed by a ``\emph{did it really happen?}'' test. This would render 
  programs unreadable and unmaintainable. Where practical, Caja deviates from 
  standard JavaScript by throwing an exception rather than failing silently.
  
  \item[Feature testing.] The JavaScript \emph{feature testing} pattern 
  relies on a failed attempt to read a property returning \code{undefined} 
  rather than throwing an exception. Since, in this case, the program 
  naturally notices the problem anyway, Caja does not turn this case into a 
  thrown exception.
    
\end{description}

This last point about ``Silent errors'' is another reason to avoid the 
monolithic kernel approach. Web apps in untranslated JavaScript are 
vulnerable to any malicious active content that finds a way to provoke a 
silent error and exploit the resulting inconsistency.

Because Caja failures aren't silent, Caja is a \emph{fail-stop 
subset}\footnote{
%
We thank Dan Rabin for this formulation.
%
} of ES3: While a Caja program has not explicitly indicated a failure, 
it executes within ES3's semantics. By \emph{indicate a failure}, we 
mean either throwing an exception or returning \code{undefined} for a 
property read. The \emph{Gotchas} sections below detail minor ways in which 
Cajita and Caja are not quite fail-stop subsets of ES3.


\section{Cajita Specification}
\label{sec:cajita-spec}

Most of the complexity of Caja is needed to defend against JavaScript's rules 
regarding the binding of ``\code{this}''. The subset of Caja without 
``\code{this}'' is a perfectly reasonable and expressive programming 
language. Caja supports ``\code{this}'' in order to ease the porting of old 
code. For new code, we recommend sticking to the thisless subset of Caja, 
which we refer to as \emph{Cajita}, the diminutive, meaning ``small 
box''.\footnote{
%
The design of Cajita was inspired by Doug Crockford's \emph{ADsafe}.
%
}

The Caja runtime will provide a safe \code{caja.eval} operation. For 
\code{caja.eval} to accept Caja code, the Caja translator would need to be 
written in JavaScript and included in the Caja download. To minimize download 
size, \code{caja.eval} will instead accept only Cajita code.

To explain the restrictions Cajita imposes, we need some definitions.

\begin{description}

  \item[JSON Container.] An object whose prototype's ``\code{constructor}'' 
  property is \code{Array} or \code{Object}, i.e., under normal conditions, 
  an object inheriting directly from \code{Array.prototype} or 
  \code{Object.prototype}. JSON containers are normally created using the
  \code{[\ldots]} or \code{\{\ldots\}} syntaxes.

  \item[Simple functions.] A function whose body does not mention 
  ``\code{this}'' is a \emph{simple function}. A simple function can be 
  either named or anonymous. A simple function can be invoked \emph{as a 
  function} (\code{foo(a\ldots)}), \emph{as a method} 
  (\code{foo.id(a\ldots)}), or \emph{as a constructor} (\code{new 
  Foo(a\ldots)}). Simple functions are first-class---they can be stored in 
  variables and passed around freely, just like any other value.
  
  \item[Frozen.] If an object is \emph{frozen}, any attempt to directly 
  assign to its properties, add new properties to it, or delete its 
  properties causes an exception to be thrown. Frozen is a shallow 
  restriction: Frozen objects can retain and provide non-frozen objects. 
  (Imagine a frozen surface covering a liquid lake.) Once initialized, Caja 
  functions are implicitly frozen. The Caja runtime library additionally 
  provides an explicit operation for freezing JSON containers: 
  ``\code{caja.freeze(obj)}''.
  
  \item[Immutable.] If an object is \emph{immutable}, then it is frozen, and 
  all objects it has access to are themselves immutable. Shared access to an 
  immutable object does not provide a communication channel, and so does not 
  endanger isolation. With the exception of \code{Math.random} and 
  \code{Date}, all objects that are globally or implicitly accessible to all 
  Caja programs are immutable. We discuss these exceptions below.

\end{description}

\subsection{Static restrictions}

Any source code statically accepted by the Caja translator is 
\emph{Caja-compliant JavaScript program text}. Source code satisfying certain 
additional static restrictions is also Cajita-compliant program text. The 
following restrictions apply to both Caja and Cajita.

\begin{description}

    \item[Stable language.] Virtually any input which should be statically 
    rejected by ES3 is forbidden, even if it would be allowed by a target 
    browser or later JavaScript specifications. This includes any use of 
    keywords reserved in ES3. But we reserve the right to include 
    \emph{de-facto extensions} to ES3 as explained below.
    
    \item[De-facto extensions.] As we identify widely supported extensions of 
    ES3 that we can accept as input, but still translate to conforming ES3 on 
    output, we may add these to Caja. For example, we are currently 
    considering allowing backslash as a line continuation character, since 
    this is allowed by virtually all JavaScript implementations and can be 
    trivially translated to correct ES3.

    \item[Without ``\code{with}''.] The ``\code{with}'' keyword is forbidden. 
    Because of the scope confusion it causes, ``\code{with}'' is a widely 
    hated and avoided feature that would be a lot of trouble to support 
    safely.

    \item[Beware unicode.] Non-Latin-1 characters are forbidden for now in 
    source text outside of string literals. Some of these create parsing 
    problems on some widely deployed JavaScript platforms. Prohibiting these 
    protects against some char-encoding attacks. We expect to relax this 
    restriction once we know how to do so safely.

    \item[Forbidden names.] An identifier ending with a double underscore is 
    forbidden, either as a variable name or a property name. We reserve the 
    triple underscore for use by the Caja translator output and the Caja 
    runtime code. Firefox reserves use of the double underscore for itself.
    
    \item[``new'' is ok.] Since Cajita does not have \code{this}, 
    constructors, nor prototypes, \code{new} isn't needed purely within 
    Cajita. But since Cajita code must interoperate smoothly with Caja and 
    untranslated JavaScript code, \code{new} is considered a valid part of 
    Cajita.
        
\end{description}

The following features are present in Caja in order to accommodate old code, 
rather than to enhance expressiveness. Since Cajita is for new code, in order 
to minimize the dowload size of the Cajita translator, as well as to simplify 
the semantics of Cajita considered on its own, these features are absent from 
Cajita. Code containing these features is not Cajita-complaint.

\begin{description}
    
    \item[``this''.] The central difference between Caja and Cajita is that 
    only Caja includes ``\code{this}''.
    
    \item[Internal names.] In Caja, an \emph{internal name} is a property 
    name ending in ``\code{\_}'' (a single underbar). Such names are used for 
    encapsulation in Caja but are prohibited in Cajita. Cajita's only 
    encapsulation mechanism is lexical scoping.
    
    \item[Prototypes.] In Caja and Cajita, if ``\code{Foo}'' is a function 
    name, then static properties of the function can be initialized until the 
    first time the function is used. Cajita prohibits access to \code{Foo}'s 
    ``\code{prototype}'' property, and so prevents use of JavaScript's 
    prototype inheritance within Cajita.
    
    \item[``instanceof''.] Without ``\code{this}'' and prototypes, Cajita has 
    no need for \code{instanceof}. Rather, JavaScript's \code{typeof} is 
    almost an adequate type discriminator for Cajita. Cajita does allow the 
    one special case meaningful within Cajita: ``\code{{\ldots}\ instanceof 
    Array}''.
    
    \item[Literal RegExp syntax.] In JavaScript implementations, the literal 
    pattern syntax is often optimized into a static object with mutable 
    state, violating isolation. Caja translates the \code{/pattern/} syntax 
    to \code{new RegExp("pattern")}. In Cajita, the second form must be
    written explicitly.
    
    \item[for/in loops.] Because of the confusing semantics of JavaScript's 
    \code{for/in} loops, these are absent from Cajita. Instead, Cajita code 
    should enumerate the properties of \code{obj} by doing
%
\begin{alltt}
    caja.each(obj, function(k, v)\ \{ 
      {\ldots}k{\ldots}v\ldots 
    \});
\end{alltt}
%
    This code will reliably give the same results whether run translated or 
    not. It will enumerate only the non-inherited publicly Caja-visible 
    properties of \code{obj}. If \code{obj instanceof Array}, then \code{k} 
    will enumerate successive indexes into the array.
    
    \item[Semicolon insertion.] Code which would provoke semicolon insertion 
    is not legal Cajita.
    
    \item[Block-breaking scopes.] Cajita variable names are visible only 
    according to the intersection of ES3's scoping rules and conventional 
    block-level lexical scoping. This is essentially lexical scoping with the 
    restriction that a function cannot contain two definitions of the same 
    variable name, even in two separate blocks. If JavaScript scope analysis
    and conventional block-level lexical scope analysis would disagree on the
    variable bindings of a given piece of code, then that code is not
    Cajita-compliant.     
    
    \item[Coercing equality.] JavaScript's coercing rules for the 
    ``\code{==}'' and ``\code{!=}'' operators are complex and accident prone. 
    Cajita only includes the equality operators ``\code{===}'' and 
    ``\code{!==}''.
        
\end{description}


\subsection{Dynamic restrictions}

\begin{description}

  \item[Frozen Functions.] An anonymous simple function is implicitly frozen. 
  A named simple function may be initialized, but is implicitly frozen 
  immediately before its first non-initializing use or escaping occurrence. 
  For example, the assignment to \code{box.toString} in 
  Figure~\ref{fig:rights-amp} will succeed, because it occurs before box is 
  implicitly frozen by the following \code{return} statement. Initializing 
  assignments can be considered declarative initializations rather than 
  mutations.
  
  \emph{Claim: No Caja program can cause a Caja-observable mutation of a 
  function or of any object Caja considers frozen.}
  
\end{description}
  
  
\begin{figure}[t!]
\begin{alltt}
function Point(x, y)\ \{
  this.x\_ = x;
  this.y\_ = y;
\};
Point.prototype.toString = function()\ \{ 
  return "<" + this.getX() + "," + 
               this.getY() + ">"; 
\};
Point.prototype.getX = function()\ \{ 
  return this.x\_; 
\};
Point.prototype.getY = function()\ \{ 
  return this.y\_; 
\};

var pt = new Point(3, 5);
\end{alltt}

\caption[A Caja Point.]{A Caja Point. The point example, written
in this common class-like pattern of Javascript programming, is valid Caja.
\code{Point} is frozen by its first use, after which neither it nor its
prototype can be further initialized. \\ } \hrule
\label{fig:caja-point}
\end{figure}


\subsection{Outer environment restrictions}

In JavaScript, all code loaded into the same JavaScript execution environment 
shares a common mutable global environment. To avoid confusion, we refer to 
the corresponding concept in Caja as the \emph{outer environment}. The Caja 
outer environment comes in two layers:

Caja's \emph{shared outer environment} contains the subset of the standard 
ES3 global environment that we deem to be safe. This includes all the objects 
and properties defined by that standard, with the following caveats. Unless 
stated otherwise, all the objects in this outer environment are transitively 
immutable, so that they provide no ambient authority to objects defined 
within this environment. The shared outer environment itself is frozen.

Each instantiation of a Caja module is a separate plugin. Each plugin 
executes with a new \emph{per-plugin outer environment} which is mutable and 
inherits from Caja's shared outer environment. Therefore, all objects within 
the same plugin can implicitly communicate and interfere with each other. 

\emph{Claim: Two separate plugins, even if they instantiate the same module, 
are isolated from each other.}


\begin{description}

    \item[eval] The Caja global environment has no ``\code{eval}'' function. 
    Instead, ``\code{Caja.eval}'' will evaluate Cajita source code (text or 
    AST) with an explicitly provided set of variable bindings to serve as its 
    initial outer environment, as explained below.
    
    \item[Function] The JavaScript \code{Function} constructor is absent from 
    the default Caja outer environment, and must not be available in Caja.
    
    \item[function.constructor] The JavaScript \code{constructor} property of 
    functions is absent from Caja.
    
    \emph{Claim: The restrictions stated in this document together make the 
    \code{Function} object unreachable from Caja programs.}

    \item[new Date()] In JavaScript, ``\code{new Date()}''  gives ambient 
    access to the current date and time, in violation of object-capability 
    rules as well as dependency injection discipline. \code{Date} is 
    therefore a member of the global environment which is not actually 
    immutable. Further, this ambient access to the current time provides a 
    timing channel, further impeding any attempts to stem the leakage of bits 
    over covert channels. Nevertheless, despite these concerns, because it 
    provides only a read-only channel for sensing the world, Caja provides 
    the JavaScript \code{Date} constructor to Caja programs.

    \item[Math.random()] The JavaScript \code{Math.random} method is not even 
    read-only. The ES3 standard places no obligations regarding quality of the
    randomness produced. In particular, an implementation could conform to ES3
    and still leak to a given caller of \code{Math.random()} the ability to
    infer how many previous times it had been called. Nevertheless, Caja
    provides the JavaScript \code{Math.random} method to Caja programs. We
    recommend that JavaScript platform providers provide good enough
    randomness that this method doesn't serve as an information channel
    between otherwise-isolated plugins.
    
\end{description}


\subsection{Cajita gotchas}

Caja seeks to define a fail-stop subset of ES3, as explained above. However, 
it falls short of this goal in several minor ways. To write a correct program 
that executes correctly whether run translated or untranslated, it should 
avoid these gotchas. In this section, we enumerate those gotchas relevant to 
the Cajita subset of Caja.

\begin{description}

  \item[Snapshot \code{arguments}.] In ES3, if \code{x} is the i'th parameter 
  of a function, assignments to \code{x} are visible as changes to 
  \code{arguments[i]}. In Caja, if ``\code{arguments}'' is mentioned, it is 
  bound to a proper array snapshot of the arguments list when the function 
  was entered, \emph{not} an array-like object. In order for Caja to be a 
  fail-stop subset of ES3, a future version of the Caja translator will 
  statically disallow assignments to any parameter variable within a function 
  that mentions ``\code{arguments}''. But in the initial Caja implementation, 
  this minor gotcha remains.
  
\end{description}

\begin{figure}[t!]
\begin{alltt}
function Point(x, y)\ \{
  this.x\_ = x;
  this.y\_ = y;
\};
Point.prototype =\ \{
  toString: function()\ \{ 
    return "<" + this.getX() + "," + 
                 this.getY() + ">"; 
  \},
  getX: function()\ \{ return this.x\_; \},
  getY: function()\ \{ return this.y\_; \}
\};
\end{alltt}

\caption[A Brief Caja Point.]{A Brief Caja Point. Caja also accepts this more
compact pattern for initializing a top-level prototype all at once.
\\ } \hrule
\label{fig:brief-caja-point}
\end{figure}


\section{Caja Specification}
\label{sec:caja-spec}

Whereas Cajita is a small subset of JavaScript meant to support new code, 
Caja is a large subset of JavaScript meant to ease the porting of old 
JavaScript code and practices. Cajita is small enough that its security 
properties can be understood. Caja seeks to accept as large a subset of 
JavaScript as is practical without losing the security properties provided by 
Cajita. In this section, we explain only the remaining elements of Caja 
beyond the elements of Cajita already explained.

To explain the remaining elements of Caja, we need some additional 
definitions.

\begin{description}

  \item[Constructed object.] An object defined by Caja code that's not a JSON 
  container and not a function must have been constructed by calling 
  ``\code{new}'' on a function other than \code{Array} or \code{Object}.

  \item[Prototypes.] As in ES3, a constructed object's implicit 
  \emph{prototype}---the object it directly inherits from---is the value of 
  the ``\code{.prototype}'' property of the function which constructed it 
  (which must have been called with ``\code{new}''). When a function is 
  implicitly frozen, so is its \code{.prototype}. Until then, both it and its 
  \code{.prototype} may be initialized. 

  \item[Constructors.] A named function whose body mentions ``\code{this}'' 
  is a \emph{constructor}. A constructor can only be invoked by construction, 
  i.e., by a call using the ``\code{new}'' keyword. To enforce this, 
  constructors are not \emph{first-class values}. A constructor definition 
  and a constructor name can only appear in certain static contexts 
  enumerated below, in order to ensure that the constructor value does not 
  escape. Like a named simple function, a constructor and its 
  ``\code{.prototype}'' may be initialized, but are implicitly frozen on 
  first use.
    
  \item[Methods.] An anonymous function whose body mentions ``\code{this}'' 
  is a \emph{method}. A method definition may only appear in prototype 
  property initializations. To avoid the confusions regarding 
  ``\code{this}'', Caja methods are also not first-class. A property holding 
  a method is \emph{call only}, it can be called but not read.
  
\end{description}

% XXX Need to justify why constructors and methods can't be first-class.
% XXX Looks like we need to distinguish between intrinsic and extrinsic
%     methods. 

\begin{figure}[t!]
\begin{alltt}
function WobblyPoint(x, y)\ \{
  Point.call(this, x, y);
\};
Caja.def(WobblyPoint, Point,\ \{
  getX: function()\ \{ 
    return Math.random() +
      Point.prototype.getX.call(this); 
  \}
\});
\end{alltt}

\caption[A Caja Subclass.]{A Caja Subclass. \code{caja.def} supports 
classical inheritance. The second argument serves as a ``superclass''. The 
third argument provides instance members including methods. A fourth optional 
argument (unshown) provides static members. When the superclass argument is a 
function name, it can be used as shown for \emph{super} construction and 
method calls. These occurrences of \code{call} are exempt from the normal 
translation rules. \\ } \hrule
\label{fig:caja-subclass}
\end{figure}


\subsection{Static restrictions}

Any source code statically accepted by the Caja translator is \emph{verified 
Caja program text}. The presence of the following syntactic elements causes 
an alleged Caja program text to instead be statically rejected.

\begin{description}

  \item[Internal properties.] An identifier ending in a single underscore may 
  be used only to name Internal properties. It may appear only after a 
  ``\code{this.}''.
  
  \item[Constructor names.] TODO
  
  \item[Methods.] TODO

  \item[Exophoric functions.] When an anonymous function mentioning 
  ``\code{this}'' appears in an illegal position for a Caja method, the Caja 
  translator currently rejects the program. A future upwards compatible 
  extension to Caja will instead classify these as \emph{exophoric functions}. 
  An exophoric function mentions ``\code{this}'', but its referent for 
  ``\code{this}'' is not statically apparent. To allow exophoric functions 
  safely, we need only impose two rules:
  
  \begin{itemize}

    \item The translator inserts a check at the beginning of exophoric 
    functions, ensuring that ``\code{this}'' isn't bound to the global 
    object. This ensures that exophoric functions cannot be called as 
    functions.
    
    \item Within an exophoric function, ``\code{this}'' is not treated 
    specially. ``\code{this.foo\_}'' is disallowed, and ``\code{this[x]}'' is 
    translated to a check that x names a \emph{publicly} readable member of 
    \code{this}.

  \end{itemize}
  
\end{description}

Although constructors are normally frozen and the ``\code{prototype}'' 
property of functions is generally not settable, we allow the 
patterns shown in Figures~\ref{fig:caja-point} and~\ref{fig:brief-caja-point} 
for declaring a constructor, initializing it, and initializing its prototype.

If the first argument to ``\code{Caja.def}'' is a function name, this is 
considered an initializing use, and so does not implicitly freeze that 
function. 

\begin{figure}[t!]
\begin{alltt}
function Brand() \{
  var flag = false;
  var squirrel = null;

  return caja.freeze(\{
    seal: function(payload) \{
      function box() \{
        squirrel = payload;
        flag = true;
      \}
      box.toString = function() \{
        return "(box)";
      \};
      return box;
    \},
    unseal: function(box) \{
      flag = false; squirrel = null;
      box();
      caja.enforce(flag,\ldots);
      return squirrel;
    \}
  \});
\}
\end{alltt}

\caption[Rights Amplification]{Rights Amplification. Each brand has a 
\code{seal} and \code{unseal} function, acting like a matched encryption and 
decryption key. Sealing an object returns a sealed \code{box} that can only 
be unsealed by the corresponding \code{unseal} function. The implementation 
technique shown here is due to Marc Stiegler.
\\ } \hrule
\label{fig:rights-amp}
\end{figure}

\begin{figure}[t!]
\begin{alltt}
function Mint() \{
  var brand = Brand();
  return function Purse(balance) \{
    caja.enforceNat(balance);
    function decr(amount) \{
      caja.enforceNat(amount);
      balance = 
        caja.enforceNat(balance - amount);
    \}
    return caja.freeze(\{
      getBalance: function() \{
        return balance; \},
      makePurse: function() \{
        return Purse(0); \},
      getDecr: function() \{
        return brand.seal(decr); \},
      deposit: function(amount,src) \{
        var newBal = 
          caja.enforceNat(balance+amount);
        var box = src.getDecr();
        brand.unseal(box)(amount);
        balance += newBal;
      \}
    \});
  \}
\}
\end{alltt}

\caption[The MintMaker Example]{The MintMaker Example. Calling \code{Mint()} 
creates a \code{Purse} function for making purses holding new transferable 
units of a distinct ``currency''. Given two purses of the same currency, one 
can transfer money between them, but one can't violate conservation of 
currency. \\ } \hrule
\label{fig:mintmaker}
\end{figure}

% XXX fig:rights-amp and fig:mintmaker need more explanation


\subsection{Dynamic restrictions}

\begin{description}

  \item[Frozen prototypes.] In Caja, until a function is frozen, both it and 
  the value of its ``\code{.prototype}'' property may be initialized. When a 
  function is frozen, so is the value of its ``\code{.prototype}'' property. 
  Therefore, only the instances at the leaves of the JavaScript inheritance 
  tree may remain unfrozen.
  
   \item[Well formed inheritance.] JavaScript provides an interesting set of 
   primitives for building non-standard inheritance arrangements. Many of 
   these arrangements will break assumptions in other code. In practice, 
   these primitives are used in a particular arrangement in which, for 
   example, for all functions \code{F}, \code{F.prototype.constructor === F}. 
   Caja allows only this classical inheritance pattern, so that Caja code and 
   the Caja implementation can rely on it.
   
   \item[Shape change.] When one adds or deletes properties of an object, we 
   can describe this as changing the shape of the object. Of course, no one 
   can change the shape of a frozen object. Anyone with access to a 
   non-frozen JSON container may freely change its shape. A constructed 
   object can directly change its own shape, by assignment or \code{delete} 
   using \code{this}. Clients of a constructed object cannot directly change 
   its shape. But since a constructed object can directly change its own 
   shape, it can provide methods enabling its clients to ask it to change its 
   shape. In other words, a constructed object has control of its own shape.
   
   Adding a property that overrides an inherited property is considered a 
   shape change, so only a constructed object may do this directly for 
   itself. If a constructed object does create a public own property, its 
   clients can directly assign to it.
   
  
\end{description}

\subsection{Caja gotchas}

Caja seeks to define a fail-stop subset of ES3, as explained above. However, 
it falls short of this goal in several minor ways. To write a correct program 
that executes correctly whether run translated or untranslated, it should 
avoid these gotchas. In this section, we enumerate those remaining gotchas
relevant specifically to Caja.

\begin{description}

  \item[Bare for/in loops.] More properties are visible and enumeratable to 
  untranslated programs than translated programs. To write a program which 
  will see the same properties whether run translated or not, write the 
  following instead:
%
\begin{alltt}
for (var k in obj) \{ 
  if (caja.canEnumPub(obj,k)) \{
    {\ldots}k{\ldots}obj[k]\ldots
  \}
\}
\end{alltt}
%
  This conditional does not affect the behavior of translated programs, so
  programs that only need to run translated can safely leave it out. Using
  \code{canEnumOwn} instead will further restrict the enumeration to
  non-inherited properties, as is typically desired. The same effect can still
  be obtained more compactly using Cajita's \code{caja.each} construct as
  explained earlier.

  \item[Isolated RegExps.] ES3 specifies that a literal regular expression 
  pattern corresponds directly to a single mutable RegExp object. Caja, as 
  well as the Internet Explorer version of JavaScript (JScript), instead 
  create a new RegExp on each evaluation of a literal pattern, avoiding the 
  implicit sharing of mutable state. For any program already compatible with 
  JScript, this is not an issue.
    
\end{description}

\section{Related work}
\label{sec:related}

\subsection{Browser Shield}

TODO To be written

\subsection{ADsafe}

TODO To be written

\section{Conclusions}

TODO To be written

\section{Acknowledgements}

We thank 
Dirk Balfanz,
Bruno Bowden,
Andrea Campi,
Doug Crockford,
Jed Donnelley,
Brendan Eich,
Adam Langley,
Marcel Laverdet,
Kevin Reid,
and
Graham Spencer.

\appendix

\section{Tables}


\begin{figure*}
\begin{tabular}{ll}
  Caja expression    & translates to ES3 code equivalent to\\ 
  \hline
  \code{with}        & /*rejected in all positions*/ \\
  \hline
  \code{this.id\_\_} & /*rejected in all positions*/ \\
  \code{foo.id\_}    & /*rejected in all positions*/ \\      
  \code{local\_\_}   & /*rejected in all positions*/ \\        
  \code{glob\_}      & /*rejected in all positions*/ \\        
  \hline
  \code{this.id}     & \code{\_\_\_.readProp(this,"id")}\\
  \code{foo.id}      & \code{\_\_\_.readPub(foo,"id")} \\
  \code{this[bar]}   & \code{\_\_\_.readProp(this,bar)} \\
  \code{foo[bar]}    & \code{\_\_\_.readPub(foo,bar)}  \\
  \code{glob}        & \code{\_\_\_OUTERS\_\_\_.glob} \\
  \hline
  \code{bar in this}           
    & \code{(bar in this) \&\& \_\_\_.canReadProp(this,bar)} \\
  \code{bar in foo}            
    & \code{(bar in foo) \&\& \_\_\_.canReadPub(foo,bar)} \\
  \code{for (key in this)\ \{\ldots\}} 
    &\code{for (key in this)
     \{if (\_\_\_.canEnumProp(this,key))\ \{\ldots\}\}}\\
  \code{for (key in foo)\ \{\ldots\}}  
    & \code{for (key in foo)
     \{if (\_\_\_.canEnumPub(foo,key))\ \{\ldots\}\}} \\
  \hline
  \code{this.id = baz}    & \code{\_\_\_.setProp(this,"id",baz)} \\
  \code{foo.id = baz}     & \code{\_\_\_.setPub(foo,"id",baz)} \\
  \code{this[bar] = baz}  & \code{\_\_\_.setProp(this,bar,baz)} \\
  \code{foo[bar] = baz}   & \code{\_\_\_.setPub(foo,bar,baz)} \\
  \code{glob = baz}       & \code{\_\_\_OUTERS\_\_\_.glob = baz} \\
  \code{var glob = baz}   & \code{\_\_\_OUTERS\_\_\_.glob = baz} \\
  \code{var glob}         & \code{\_\_\_OUTERS\_\_\_.glob = undefined} \\
  \hline               
  \code{delete this.id}   & \code{\_\_\_.deleteProp(this,"id")} \\
  \code{delete foo.id}    & \code{\_\_\_.deletePub(foo,"id")} \\
  \code{delete this[bar]} & \code{\_\_\_.deleteProp(this,bar)} \\
  \code{delete foo[bar]}  & \code{\_\_\_.deletePub(foo,bar)} \\
  \code{delete glob}      
         & \code{\_\_\_.enforce(delete \_\_\_OUTERS\_\_\_.glob,\ldots)} \\
\end{tabular}

\caption[Translating Property Access]{Translating Property Access. Under the 
assumption that the Caja runtime environment is as specified, the Caja 
translator generates translations equivalent to those specified above, but 
inlined and optimized where possible. The meaning of translating is thereby 
determined by the specification of these entry points into the Caja runtime 
library. Where we show a translation apparently duplicating an expression, 
the translator instead introduces temporary variables as needed so that each 
expression evaluates exactly as many times and in the same order as in the 
original.}
\label{tab:prop-xlate}
\end{figure*}


\begin{figure*}
\begin{tabular}{ll}
  Caja expression & translates to ES3 code equivalent to\\ 
  \hline
                 & \code{\_\_\_.loadModule(function(\_\_\_OUTERS\_\_\_)\ \{}\\
  /*caja module body*/      
                 & \code{\ \ } /*translated module body*/ \\
                 & \code{\});} \\
  \hline
  \code{this.id(a\ldots)} 
                            & \code{\_\_\_.callProp(this,"id",[a\ldots])} \\
  \code{foo.id(a\ldots)}  
                            & \code{\_\_\_.callPub(foo,"id",[a\ldots])} \\
  \code{this[bar](a\ldots)} 
                            & \code{\_\_\_.callProp(this,bar,[a\ldots])} \\
  \code{foo[bar](a\ldots)}  
                            & \code{\_\_\_.callPub(foo,bar,[a\ldots])} \\
  \code{new foo(a\ldots)}   & \code{new (\_\_\_.asCtor(foo))(a\ldots)} \\
  \code{foo(a\ldots)}       & \code{\_\_\_.asSimpleFunc(foo)(a\ldots)} \\
  \hline
  \code{function C(a\ldots)\ \{}
                 & \code{var C = \_\_\_.ctor(function(a\ldots)\ \{} \\
  \code{\ \ C.Super.call(this,b\ldots);}
                 & \code{\ \ C.Super.call\_\_\_(this,b\ldots);} \\
  \code{\ \ \ldots\};}
                 & \code{\ \ \ldots\});} \\
  \code{function C(a\ldots)\ \{}
                 & \code{var C = \_\_\_.ctor(function(a\ldots)\ \{} \\
  \code{\ \ {\ldots}this\ldots\};}
                 & \code{\ \ {\ldots}this\ldots\});}\\
  \hline
  \code{function(a\ldots)\ \{}
                 & \code{\_\_\_.method(C,function(a\ldots)\ \{} \\
  \code{\ \ {\ldots}this\ldots\}}
                 & \code{\ \ {\ldots}this\ldots\})}\\
  \hline
  \code{function F(a\ldots)\ \{}
                 & \code{var F = \_\_\_.simpleFunc(function(a\ldots)\ \{} \\
  \code{\ \ \ldots\};}         & \code{\ \ \ldots\});} \\
  
  \code{function F(a\ldots)\ \{}
    & \code{var F = \_\_\_.freeze(\_\_\_.simpleFunc(function(a\ldots)\ \{} \\
  \code{\ \ \ldots\}}         & \code{\ \ \ldots\}))} \\
  
  \code{function(a\ldots)\ \{}
             & \code{\_\_\_.freeze(\_\_\_.simpleFunc(function(a\ldots)\ \{} \\
  \code{\ \ \ldots\}}          & \code{\ \ \ldots\}))} \\
  \hline
  \code{arguments.callee}      & /*rejected*/ \\
  \code{{\ldots}arguments\ldots} 
                   &\code{var \_\_\_args\_\_\_ = \_\_\_.args(arguments);}\\
                   & \code{{\ldots}\_\_\_args\_\_\_\ldots} \\
  \hline
  \code{/pattern/} & \code{new RegExp("pattern")} \\
  \code{/pattern/flags} 
     & \code{new RegExp("pattern", "flags")} /* where flags is [igm]* */ \\
\end{tabular}

\caption[Translating Callers and Callees]{Translating Callers and Callees. A 
translated Caja module can be loaded/evaled once, creating an anonymous 
plugin-maker function. Each time the plugin-maker representing a module is 
called, it makes a new plugin. Unless their creator puts them in contact, 
even plugins made by the same plugin-maker are isolated from each other. The 
expansions above have additional static restrictions explained in the text. 
The use of a terminal ``\code{;}'' is shorthand for testing whether the 
matching expression is evaluated for effects only, not for its value.}
\label{tab:call-xlate}
\end{figure*}



\begin{figure*}
\begin{tabular}{ll}
  Caja expression & Special cases for function names and methods \\ 
  \hline
           \multicolumn{2}{c}{initialize, don't freeze \code{Foo}} \\
  \code{Foo.prototype.id = member;} & \\
  \code{Foo.prototype = \{\ldots: member, {\ldots}\};} & \\
  \code{Foo.id = \ldots; } & \\
  \code{caja.def(Foo,Base)} & \\
  \code{caja.def(Foo,Base,} & \\
  \code{\ \ \ \ \ \ \ \ \ \{\ldots: member, {\ldots}\},} & \\
  \code{\ \ \ \ \ \ \ \ \ \ldots)} & \\
  \hline
   \multicolumn{2}{c}{freeze \code{Foo} to prevent further initialization} \\
  \code{new Foo(\ldots)} & \\ 
  \code{caja.def(Derived,Foo)} & \\
  {\ldots}Foo{\ldots} & For any other occurrence, if \code{Foo} is a \\
                      & \ \ - constructor name, then it is disallowed. \\
                      & \ \ - function name, then it is frozen. \\
  \hline
  \code{\ldots\ instanceof Foo} & allow, whether \code{Foo} frozen or not \\
  \code{Foo = \ldots} & reject assignment to a function/constructor name \\
  \hline
     \multicolumn{2}{c}{can only happen if \code{Foo} is already frozen} \\ 
          \code{Foo.Super.call(this,\ldots);} & Only at start of \code{Foo},\\
                       & and only if the remaining args have no \code{this}.\\
  \code{Foo.call(this,\ldots);}     & Only at start of \code{Derived}, \\
                       & and only if the remaining args have no \code{this}.\\
  \code{Foo.prototype.id.call(this,\ldots)} 
                                    & Only within methods of \code{Derived} \\   
\end{tabular}

\caption[Special cases]{Special cases. When \code{Foo} is the name of a named
function or a constructor, then these special cases are checked before the
general translations rules. At the \code{member} positions above, either
normal expressions or methods may appear.}
\label{tab:special-cases}
\end{figure*}


\begin{figure*}
\begin{tabular}{ll}
  Methods of \code{\_\_\_}  & method body \\ 
  \hline 
  \code{enforce(test,complaint)}
       & \code{if (test)\ \{ return true; \}} \\
       & \code{throw new CajaRuntimeError(complaint);} \\
  \hline
  \code{canRead(obj,name)}  
       & \code{return !!obj[name+"\_canRead\_\_\_"];} \\
  \code{canEnum(obj,name)}
       & \code{return !!obj[name+"\_canEnum\_\_\_"];} \\
  \code{canCall(obj,name)}
       & \code{return !!obj[name+"\_canCall\_\_\_"];} \\
  \code{canSet(obj,name)}
       & \code{return !!obj[name+"\_canSet\_\_\_"];} \\
  \code{canDelete(obj,name)}
       & \code{return !!obj[name+"\_canDelete\_\_\_"];} \\
  \hline
  \code{allowRead(obj,name)}* 
       & \code{obj[name+"\_canRead\_\_\_"] = true;} \\
  \code{allowEnum(obj,name)}* 
       & \code{allowRead(obj,name);} \\
       & \code{obj[name+"\_canEnum\_\_\_"] = true;} \\
  \code{allowCall(obj,name)}* 
       & \code{obj[name+"\_canCall\_\_\_"] = true;} \\
  \code{allowSet(obj,name)}* 
       & \code{enforce(!isFrozen(obj),\ldots);} \\
       & \code{allowEnum(obj,name);} \\
       & \code{obj[name+"\_canSet\_\_\_"] = true;}\\
  \code{allowDelete(obj,name)}* 
       & \code{enforce(!isFrozen(obj),\ldots);} \\
       & \code{obj[name+"\_canDelete\_\_\_"] = true;} \\
       & /*other bookkeeping yet to be determined*/ \\
  \hline 
  \code{hasOwnProp(obj,name)} 
       & /*like the original: \code{obj.hasOwnProperty(name)}*/ \\
  \code{isJSONContainer(obj)} 
       & \code{var Constr = directConstructor(obj);} \\
       & \code{return Constr === Object || Constr === Array;} \\ 
  \code{isFrozen(obj)} 
       & \code{return hasOwnProp(obj,"\_\_\_FROZEN\_\_\_");} \\
  \code{freeze(obj)}*
       & \code{for (k in obj)\ \{} \\
       & \code{\ \ if
        (endsWith(k,"\_canSet\_\_\_")||endsWith(k,"\_canDelete\_\_\_"))\ \{}\\
       & \code{\ \ \ \ obj[k] = false;\}\}}\\ 
       & \code{obj.\_\_\_FROZEN\_\_\_ = true;} \\
       & \code{if (typeof obj === "function") \{ freeze(obj.prototype); \}}\\
       & \code{return obj;} \\
  \hline 
  \code{method(Constr,meth)}
       & \code{enforce(typeof Constr === "function",\ldots);} \\
       & \code{enforce(typeof meth === "function",\ldots);} \\
       & \code{meth.\_\_\_METHOD\_OF\_\_\_ = Constr;} \\
       & \code{return freeze(meth);} \\
  \code{allowMethod(Constr,name)}*
       & \code{method(Constr,Constr.prototype[meth]);} \\
       & \code{allowCall(Constr,name);} \\
\end{tabular}

\caption[Hidden Attributes.]{Hidden Attributes. These methods handle the 
concrete representations of object and property attributes. Only methods 
marked with a * should be called by JavaScript code during initialization of 
the embedding app to express taming decisions. All objects that are reachable 
from the ES3 shared environment should be frozen, so that the shared 
environment is transitively read-only to all Caja code.}
\label{tab:hide-attr}
\end{figure*}


\begin{figure*}
\begin{tabular}{ll}
  Methods of \code{\_\_\_}  & method body \\ 
  \hline 
  \code{canReadProp(that,name)}
       & \code{if (endWith(name,"\_\_"))\ \{ return false; \}} \\
       & \code{return canRead(that,name);} \\
  \code{readProp(that,name)}
       & \code{return canReadProp(that,name) ?\ that[name] :\ undefined;} \\
  \code{canReadPub(obj,name)}
       & \code{if (endWith(name,"\_"))\ \{ return false; \}} \\
       & \code{if (canRead(obj,name))\ \{ return true; \}} \\
       & \code{if (!isJSONContainer(obj))\ \{ return false; \}} \\
       & \code{if (!hasOwnProp(obj,name))\ \{ return false; \}} \\
       & \code{allowRead(obj,name);} /*memoize*/ \\
       & \code{return true;} \\
  \code{readPub(obj,name)}
       & \code{return canReadPub(obj,name) ?\ obj[name] :\ undefined;} \\
  \hline
  \code{canEnumProp(that,name)} 
       & \code{if (endWith(name,"\_\_"))\ \{ return false; \}} \\
       & \code{return canEnum(that,name);} \\
  \code{canEnumPub(obj,name)}
       & \code{if (endWith(name,"\_\_"))\ \{ return false; \}} \\
       & \code{if (canEnum(obj,name))\ \{ return true; \}} \\
       & \code{if (!isJSONContainer(obj))\ \{ return false; \}} \\
       & \code{if (!hasOwnProp(obj,name))\ \{ return false; \}} \\
       & \code{allowEnum(obj,name);} /*memoize*/ \\
       & \code{return true;} \\
  \hline
  \code{canSetProp(that,name)}
       & \code{if (endWith(name,"\_\_"))\ \{ return false; \}} \\
       & \code{if (canSet(that,name))\ \{ return true; \}} \\
       & \code{return !isFrozen(that);} \\
  \code{setProp(that,name,val)}
       & \code{enforce(canSetProp(that,name),\ldots);} \\
       & \code{allowSet(that,name);} /*grant*/ \\
       & \code{return that[name] = val;} \\
  \code{canSetPub(obj,name)}
       & \code{if (endWith(name,"\_"))\ \{ return false; \}} \\
       & \code{if (canSet(obj,name))\ \{ return true; \}} \\
       & \code{return !isFrozen(obj) \&\& isJSONContainer(obj);} \\
  \code{setPub(obj,name,val)}
       & \code{enforce(canSetPub(obj,name),\ldots);} \\
       & \code{allowSet(obj,name);} /*grant*/ \\
       & \code{return obj[name] = val;} \\
  \hline               
  \code{deleteProp(that,name)} 
       & \code{enforce(canDeleteProp(that,name),\ldots);} \\
       & /*XXX Bookkeeping yet to be determined*/ \\
       & \code{return enforce(delete that[name],\ldots);} \\
  \code{deletePub(obj,name)} 
       & \code{enforce(canDeletePub(obj,name),\ldots);} \\
       & \code{enforce(isJSONContainer(obj),\ldots);} \\
       & /*XXX Bookkeeping yet to be determined*/ \\
       & \code{return enforce(delete obj[name],\ldots);} \\
  \hline
  \code{args(original)}
       & \code{return freeze(Array.prototype.slice.call\_\_\_(original,0));}
\end{tabular}

\caption[Property Access.]{Property Access. The calls to \code{allowRead} and
\code{allowEnum} merely memoize a query result. The calls to \code{allowSet}
track the implications of side effects.}
\label{tab:prop-access}
\end{figure*}


\begin{figure*}
\begin{tabular}{lll}
  Global ES3 non-constructor & Property                   & Taming \\
  \hline
  \code{NaN}                &                             & ok \\
  \code{Infinity}           &                             & ok \\
  \code{undefined}          &                             & ok \\
  \code{eval}               &                             & hidden \\
  \code{parseInt}           &                             & ok \\
  \code{parseFloat}         &                             & ok \\
  \code{isNaN}              &                             & ok \\
  \code{isFinite}           &                             & ok \\
  \hline
  \code{decodeURI}          &                             & ok \\
  \code{decodeURIComponent} &                             & ok \\
  \code{encodeURI}          &                             & ok \\
  \code{encodeURIComponent} &                             & ok \\
  \hline
  \code{Math}               &                             & ok \\  
                            & \code{random}               & callable* \\
                            &           all others in ES3 & ok, callable \\
\end{tabular}

\caption[Taming ES3 Global Non-Constructors.]{Taming ES3 Global 
Non-Constructors. Except for \code{eval}, all non-constructors specified by 
ES3 are visible in Caja's outer environment as immutable objects. Note that 
\code{Math.random} is not actually immutable, and therefore neither is 
\code{Math} nor Caja's outer environment itself. We allow it anyway for 
reasons explained in the text.}
\label{tab:taming-es3}
\end{figure*}


\begin{figure*}
\begin{tabular}{lll}
  Global ES3 constructor         & Property                    & Taming \\
  \hline 
  constructor                    &                             & default ctor \\
  constructor\code{.prototype}   &                             & default ok \\
                                 & \code{constructor}          & hidden \\
                                 & \code{toString}             & default method \\
                                 & \code{toLocaleString}       & default method \\
                                 & \code{valueOf}              & default method \\
  instances                      & \code{length}               & default ok \\
  \hline
  \code{Object.prototype}        & \code{hasOwnProperty}       & handled \\
                                 & \code{isPrototypeOf}        & method \\
                                 & \code{propertyIsEnumerable} & handled \\
                                 & \code{freeze\_}             & added method \\
  \hline
  \code{Function}                &                             & hidden \\
  \code{Function.prototype}      &                             & ok \\
                                 & \code{apply}                & handled \\
                                 & \code{call}                 & handled \\
  instances                      & \code{prototype}            & ok \\
                                 & \code{length}               & ok \\
  \hline
  \code{Array.prototype}         & \code{concat}               & method \\
                                 & \code{join}                 & method \\
                                 & \code{pop}                  & handled \\
                                 & \code{push}                 & handled \\
                                 & \code{reverse}              & handled \\
                                 & \code{shift}                & handled \\
                                 & \code{slice}                & method \\
                                 & \code{sort}                 & handled \\
                                 & \code{splice}               & handled \\
                                 & \code{unshift}              & handled \\
                                 & \code{indexOf}              & added method \\
                                 & \code{lastIndexOf}          & added method \\
  \hline
  \code{String}                  & \code{fromCharCode}         & callable \\
  \code{String.prototype}        & \code{match}                & handled \\
                                 & \code{replace}              & handled \\
                                 & \code{search}               & handled \\
                                 & \code{split}                & handled \\
                                 &           all others in ES3 & ok, method \\
\end{tabular}

\caption[Taming ES3 Global Constructors, Part 1.]{Taming ES3 Global 
Constructors, Part 1. The first section above shows the taming decisions that 
apply by default to global ES3 constructors, their prototypes, and their 
instances, unless stated otherwise in a specific table entry. A 
\emph{handled} method acts differently when called by translated Caja code 
than for untranslated JavaScript code. The handled \code{call} and 
\code{apply} methods can only be invoked on simple functions. Handled 
mutating methods like \code{Array.pop} obey Caja's mutability constraints. }
\label{tab:taming-es3-1}
\end{figure*}



\begin{figure*}
\begin{tabular}{lll}
  Global ES3 constructor         & Property                    & Taming \\
  \hline 
  \code{Boolean}                 &                             & ctor \\
  \hline
  \code{Number}                  & \code{MAX\_VALUE}           & ok \\
                                 & \code{MIN\_VALUE}           & ok \\
                                 & \code{NaN}                  & ok \\
                                 & \code{NEGATIVE\_INFINITY}   & ok \\
                                 & \code{POSITIVE\_INFINITY}   & ok \\
  \code{Number.prototype}        & \code{toFixed}              & method \\
                                 & \code{toExponential}        & method \\
                                 & \code{toPrecision}          & method \\
  \hline
  \code{Date}                    &                             & ctor* \\
                                 & \code{parse}                & callable \\
                                 & \code{UTC}                  & callable \\
  \code{Date.prototype}          & \code{to*String} all in ES3 & method \\
                                 & \code{toISOString}          & added method \\
                                 & \code{get*}      all in ES3 & method \\
                                 & \code{set*}      all in ES3 & handled \\
  \hline
  \code{RegExp.prototype}        & \code{exec}                 & handled \\
                                 & \code{test}                 & handled \\
  instances                      & \code{source}               & ok \\
                                 & \code{global}               & ok \\
                                 & \code{ignoreCase}           & ok \\
                                 & \code{multiline}            & ok \\
                                 & \code{lastIndex}            & ok \\
  \hline 
  \code{Error.prototype}         & \code{name}                 & ok \\
                                 & \code{message}              & ok \\
  \code{*Error}                  &                  all in ES3 & ok \\
  \code{*Error.prototype}        &                  all in ES3 & ok \\
  
\end{tabular}

\caption[Taming ES3 Global Constructors, Part 2.]{Taming ES3 Global
Constructors, Part 2. The \code{Date} constructor itself gives ambient
read-only access to the current time, and is therefore not immutable.
We allow it anyway for reasons explained in the text.} 

\label{tab:taming-es3-2}
\end{figure*}


\bibliographystyle{abbrv}
\bibliography{common}

\end{document}
